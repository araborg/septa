<!-- 
https://randoma11y.com/

A. Introduction to CSS:


1. What is CSS?
===============

CSS defines how elements should be rendered on the 
screen, in print, or by other media. It allows
developers to style web pages independently from 
the structure, (HTML).


History and Evolution of CSS
============================

CSS has evolved through various levels:

CSS1 (1996): The first official specification by 
the World Wide Web Consortium (W3C). It introduced 
basic styling features.

CSS2 (1998): Added new features like positioning, 
z-index, media types, and downloadable fonts.

CSS2.1 (2011): An update to CSS2 that refined and 
corrected the CSS2 specification.

CSS3 (Late 2000s-Present): Introduced modules allowing 
independent updates. Features include rounded corners, 
shadows, gradients, transitions, animations, and much 
more.

CSS4 (Ongoing): Rather than a single specification, 
CSS4 is more of a collection of modules that continue 
to evolve.


How CSS Integrates with HTML
============================

CSS integrates with HTML in three main ways:

1. Inline CSS: 
Styles are applied directly to HTML elements using the 
style attribute. 

Example:

<p 
    style="color: blue; font-size: 14px;"
>
    This is a blue paragraph.
</p>

2. Internal CSS: 
Styles are defined within the <style> element in the 
<head> section of an HTML document. 

Example:

<head>
    <style>
        p {
            color: green;
            font-size: 16px;
        }
    </style>
</head>

3. External CSS: 
Styles are written in a separate CSS file and linked 
to an HTML document using the <link> element. This is 
the most preferred way as it keeps HTML and CSS 
separate. 

Example:

<head>
    <link rel="stylesheet" type="text/css" href="styles.css">
</head>




2. CSS Syntax Selectors Properties
==================================
CSS syntax is structured into three main parts:

Selector: 
Identifies the HTML element(s) to be styled.

Property: 
Specifies the aspect of the element to be styled 
(e.g., color, font-size, margin).

Value: 
Defines the style for the property.

The basic structure of a CSS rule is:
selector {
    property: value;
}

For example:

p {
    color: red;
    font-size: 16px;
}

This rule applies to all <p> elements, setting their 
text color to red and font size to 16 pixels.

Basic Selectors:

Element Selector: 
Targets all instances of a given HTML element.

h1 {
    color: blue;
}

This rule changes the text color of all <h1> elements 
to blue.

Class Selector:
Targets elements with a specific class attribute. It 
is defined using a dot (.) followed by the class name.

.highlight {
    background-color: yellow;
}

This rule applies a yellow background to all elements 
with the class highlight.

ID Selector: 
Targets a single element with a specific ID attribute. 
It is defined using a hash (#) followed by the ID name.

#main-title {
    font-weight: bold;
}

This rule makes the text of the element with the ID 
main-title bold.


Grouping and Combining Selectors:

Grouping Selectors: 

Multiple selectors can be grouped to apply the same 
style to different elements.

h1, h2, h3 {
    color: green;
}

This rule applies a green color to all <h1>, <h2>, 
and <h3> elements.


Combining Selectors: 

You can combine selectors to target elements more 
specifically.

E.g:
Descendant Selector: div p {}

Child Selector: p > a {}

Adjacent Sibling Selector: h1 + h3

General Sibling Selector: h2 ~ p {}


Descendant Selector: div p {}
Targets elements INSIDE other elements.

ul li {
    color: purple;
}

This rule changes the text color of ALL <li> elements 
inside a <ul> to purple.


Child Selector: p > a {}
Targets immediate/direct child elements.

<div class="container">
    <p>This is a direct child paragraph.</p>

    <div>
        <p>This is a nested paragraph, not a direct child of .container.</p>
    </div>
</div>

container > p {
    font-style: italic;
}

This rule italicizes the text of <p> elements that is a 
direct children of a <div> with class container.

Adjacent Sibling Selector: h1 + h3
Targets elements immediately following a specified element.

<div class="container">
    <h2>Section Title</h2>
    <p>
        This is the first paragraph that is immediately after h2.
    </p>

    <p>This is the second paragraph.</p>

    <ul>
        <li>Item 1</li>
        <li>Item 2</li>
    </ul>
    
    <p>This is a paragraph after a list.</p>
</div>

h2 + p {
    margin-top: 20px;
}

This rule adds a 20-pixel top margin to d first <p> 
elements immediately following an <h2>.


General Sibling Selector: 
Targets all siblings following a specified element.

<div class="container">
    <h2>Main Heading</h2>

    <p>Paragraph 1</p>
    
    <div>Another Div</div>
    
    <p>Paragraph 2</p>
    
    <span>A Span</span>
    
    <p>Paragraph 3</p>
</div>

h2 ~ p {
    font-size: 14px;
}

This rule changes the font size of ALL <p> elements that 
follow an <h2>.




Methods of Applying CSS:
========================

There are three primary methods to apply CSS to HTML documents: 
inline, internal, and external. Each method serves different 
purposes and has its advantages and disadvantages.

I. Inline CSS:
CSS is applied directly to an HTML element using the style 
attribute.

Syntax:

<p style="color: blue; font-size: 14px;">
    This is a paragraph with inline CSS.
</p>

Advantages: 
Quick and useful for single-use styles or testing.

Disadvantages: 
Difficult to maintain and manage across large projects.

II. Internal CSS:
CSS is defined within the <style> tag inside the <head> 
section of an HTML document.

Syntax:

<head>
    <style>
        p {
            color: green;
            font-size: 16px;
        }
    </style>
</head>

Advantages:
Keeps CSS in one place, making it easier to manage than 
inline CSS.

Disadvantages: 
Styles are not reusable across multiple pages.

III. External CSS:
CSS is written in a separate file (with a .css extension) 
and linked to the HTML document using the <link> tag.

Syntax:

<head>
    <link rel="stylesheet" href="styles.css">
</head>

In styles.css:

p {
    color: red;
    font-size: 18px;
}

Advantages: 
Allows for reusability across multiple pages, making 
it the most efficient and maintainable method for 
large projects.

Disadvantages: 
Requires an additional file, which could potentially 
increase the number of HTTP requests.


The <style> Tag and <link> Tag

The <style> Tag:
Used for internal CSS.
Placed within the <head> section of the HTML document.

Allows you to define CSS styles directly within the HTML 
file.

Example:

<head>
    <style>
        body {
            background-color: lightgray;
        }
    </style>
</head>


The <link> Tag:
Used for external CSS.
Also placed within the <head> section.

Links an external CSS file to the HTML document.

Example:

<head>
    <link rel="stylesheet" href="main.css">
</head>


Best Practices for Organizing CSS

Modularity:
Break CSS into smaller, manageable files. For example, 
create separate CSS files for layout, typography, and 
components.

Commenting:
Use comments to explain sections of your CSS code, 
especially when styling is complex.

Consistent Naming Conventions:
Use meaningful class and ID names. Consider adopting 
a naming convention like BEM (Block, Element, Modifier) 
to enhance readability and maintainability.

Avoid Inline CSS:
Reserve inline CSS for testing or very specific, 
single-use cases.

Minimize Specificity:
Overly specific selectors can make CSS difficult to 
manage and override. Aim for less specificity when 
possible to maintain flexibility.

Keep It Organized:
Structure your CSS in a logical order, such as global 
styles, layout, components, utilities, etc.




CSS Units and Values:
=====================

CSS units and values are the building blocks of styling 
and positioning in web design. They define dimensions, 
colors, and various other attributes in a precise way. 

This lesson covers the essential units and values you'll
use frequently in your CSS.

Absolute:
Pixels (px): Border

Relative:
Em (em), Rem (rem): Typography
Percentage (%): Width, Height, Position


Understanding Length Units

I. Absolute Units:
Pixels (px): Border
A fixed unit, perfect for scenarios where you want precise 
control over the size. 

Ideal for borders, padding, and fixed dimensions.

Example: width: 200px;

Centimeters (cm), Millimeters (mm), Inches (in), Points (pt), 
Picas (pc): Rarely used in web design but available for 
precise print-style layouts.


II. Relative Units:
Em (em): Typography
Relative to the font size of the element's parent. 
Useful for scalable design, particularly typography.

Example: font-size: 2em; 
(twice the size of the parent’s font)

Rem (rem): Typography
Relative to the font size of the root element (<html>). 
Offers a consistent size across the entire document.

Example: font-size: 1.5rem; 
(1.5 times the root element’s font size)


Percentage (%): Width, Height, Position
Relative to the parent element's size. Commonly used for 
widths, heights, and positioning.

Example: width: 50%; (half the width of the parent)

Viewport Width (vw) and Viewport Height (vh): 
Percentage of the viewport's dimensions. 
Great for responsive design.

Example: width: 100vw; (full viewport width)

Viewport Min (vmin) and Viewport Max (vmax): 
Based on the smaller or larger dimension of the viewport, 
respectively.

Example: font-size: 3vmin; 
(3% of the smaller viewport dimension)

Color Values

I. Hexadecimal (#RRGGBB or #RGB):
A six-digit (or three-digit shorthand) hexadecimal notation. 
Each pair represents red, green, and blue.

Example: color: #ff0000; (red)

II. RGB (rgb(red, green, blue)):
Specifies colors using red, green, and blue components with 
values between 0 and 255.

Example: color: rgb(255, 0, 0); (red)

III. RGBA (rgba(red, green, blue, alpha)):
Similar to RGB, but includes an alpha channel for opacity. 
Alpha values range from 0 (completely transparent) to 1 
(completely opaque).

Example: color: rgba(255, 0, 0, 0.5); (red with 50% transparency)

IV. HSL (hsl(hue, saturation, lightness)):
Defines colors by hue (degree on the color wheel), 
saturation (percentage), and lightness (percentage).

Example: color: hsl(0, 100%, 50%); (red)

V. HSLA (hsla(hue, saturation, lightness, alpha)):
Extends HSL with an alpha channel for opacity.

Example: color: hsla(0, 100%, 50%, 0.5); (red with 50% 
transparency)


Other Common Values

I. Auto:
Allows the browser to automatically calculate the 
property’s value, commonly used with margins for 
centering elements.

Example: margin: auto;

II. Inherit:
Forces the property to inherit its value from its 
parent element.

Example: color: inherit;

III. Initial: i.e. Use Default Value
Sets the property to its default value.

Example: font-style: initial;

Summary
Understanding CSS units and values is crucial for 
creating flexible, responsive, and visually appealing 
web pages. By mastering these concepts, you’ll be able 
to make informed decisions about layout, typography, 
and color usage across your projects.




The Box Model:
==============

The CSS box model is a fundamental concept in web design 
that defines how elements are displayed and how they 
interact with each other. 

It encompasses the element’s content, padding, border, 
and margin. Understanding the box model is crucial for 
creating well-structured and responsive layouts.

Understanding the Box Model

I. Content:
This is the actual content of the box, such as text, 
images, or other elements. The size of the content can 
be controlled using the width and height properties.

II. Padding:
Padding is the space between the content and the border 
of the box. It can be set individually for each side 
(padding-top, padding-right, padding-bottom, padding-left) 
or all at once (padding).

Example: 

padding: 10px 20px; 
(10px top and bottom, 20px left and right)

III. Border
The border is the line around the padding and content. 
Like padding, it can be styled individually for each side 
or all at once. 

The border property includes the width, style, and color.

Example: 
border: 2px solid #000; 
(2px solid black border)

IV. Margin:
Margin is the space outside the border, separating the 
element from its neighbors. It can also be set individually 
or all at once.

Example: 
margin: 5px 10px; 
(5px top and bottom, 10px left and right) 

V. Width and Height:
By default, width and height apply only to the content 
of an element. Padding, borders, and margins are added 
outside these dimensions, potentially affecting the 
total size of the element.

Example: 
width: 200px; height: 100px;

VI. Box-Sizing:
The box-sizing property alters how the width and height 
properties are calculated.

Content-Box: 
This is the default value. The width and height properties 
include only the content, not padding, borders, or margins.

Border-Box: 
The width and height properties include the content, 
padding, and border, making it easier to set the size 
of an element without calculating these separately.

Example: box-sizing: border-box;


Working with Overflow and Visibility

I. Overflow:
The overflow property controls what happens when the 
content exceeds the dimensions of the box.

Visible: 
The overflow is not clipped; it renders outside the 
element’s box.

Hidden: 
The overflow is clipped, and the rest of the content 
will be invisible.

Scroll: 
Adds a scrollbar to see the overflow content

Auto: 
Adds a scrollbar only if needed.

Example: overflow: auto;

II. Visibility:
The visibility property determines whether an element is 
visible or hidden.

Visible: 
The element is visible (default).

Hidden: 
The element is not visible but still takes up space.
Example: visibility: hidden;


List 5 elements that are inline by default, and other
elements that are inline-block by default.




B. Text and Font Styling:

1. Font Properties:
===================
CSS offers various properties to define and control the 
appearance of text, making it an essential tool for web 
developers. Below are the key font properties:

I. font-family:
This property specifies the font to be used for an element. 
It accepts a list of font names, where the browser will use 
the first available font. For example:

p {
    font-family: Arial, Helvetica, sans-serif;
}

It is a good practice to include a generic font family at 
the end of the list for browsers that may not have the 
specific font installed.

II. font-size:
This property sets the size of the text. It can be defined 
using various units like pixels (px), em units (em), or 
percentages (%). For example:

p {
    font-size: 16px;
}

III. font-weight:
This property determines the boldness of the text. It can 
take values like normal, bold, bolder, lighter, or numeric 
values ranging from 100 to 900. For example:

p {
    font-weight: bold;
}

IV. font-style:
This property sets the style of the font, such as normal, 
italic, or oblique. For example:

p {
    font-style: italic;
}

Text Alignment, Decoration, and Transformation

I. Text Alignment:
The text-align property specifies the horizontal alignment 
of text in an element. It can take values such as left, 
right, center, or justify. For example:

p {
    text-align: center;
}

II. Text Decoration:
The text-decoration property adds decorations to text, such 
as underlines, overlines, or line-through. For example:

a {
    text-decoration: none;
}

III. Text Transformation:
The text-transform property controls the capitalization of 
text. It can be used to make text uppercase, lowercase, or 
capitalize the first letter of each word. For example:

p {
    text-transform: uppercase;
}

Line Height and Letter Spacing

I. Line Height:
The line-height the property specifies the space above and 
below inline elements. It helps to improve the readability 
of text by adjusting the vertical spacing between lines. 

For example:

p {
    line-height: 1.5;
}

II. Letter Spacing:
The letter-spacing property controls the space between 
characters in a text. It can be used to increase or 
decrease the spacing. For example:

p {
    letter-spacing: 2px;
}

Practical Application
To illustrate the combined use of these properties, 
consider the following example:

p {
    font-family: 'Roboto', sans-serif;
    font-size: 18px;
    font-weight: 400;
    font-style: normal;
    text-align: justify;
    text-decoration: underline;
    text-transform: capitalize;
    line-height: 1.6;
    letter-spacing: 1px;
}

This style rule sets a specific font with a moderate 
size and weight, italicizes the text, aligns it to 
the center, and applies a combination of line height 
and letter spacing to enhance readability. The text 
is capitalized with a thin line underneath, 
emphasizing a clean and modern appearance.




2. Working with Web Fonts:
==========================

Web fonts allow designers and developers to use fonts 
that aren't installed on the user's device. Instead, 
these fonts are downloaded from the web, providing 
more typography flexibility and enhancing the overall 
design of a website.

Why Use Web Fonts?
Consistency: 
Ensure the same font appears across all devices and 
browsers.

Design Variety: 
Choose from a vast selection of fonts to match the 
website's aesthetic.

Branding: 
Maintain brand consistency with specific fonts.

Using Google Fonts and Custom Fonts
Google Fonts is a popular and free web font library 
that offers a vast collection of fonts that are easy 
to integrate into your website.

A. Selecting a Font:
Visit Google Fonts and browse or search for fonts.
https://fonts.google.com/

Click on a font to view its details, styles, and 
character sets.

B. Embedding a Font:
Once you've chosen a font, click on the “Select 
this style” button.

On the sidebar, you’ll see a link tag that you can 
copy and paste into the <head> section of your HTML 
document:

<link 
    rel="stylesheet" 
    href="https://fonts.googleapis.com/css2?family=Roboto&display=swap"
>

C. Using the Font in CSS:
After embedding the font, apply it to your elements 
using the font-family property:

body {
    font-family: 'Roboto', sans-serif;
}

Custom Fonts
To use a custom font not available on Google Fonts or 
another library, you need to host the font files on 
your server.

I. Uploading the Font:
Upload the font files (usually .woff, .woff2, .ttf, 
or .otf formats) to your website’s directory.

II. Defining the Font in CSS:
Use the @font-face rule to define the custom font in 
your CSS:

@font-face {
    font-family: 'MyCustomFont';

    src: url('/fonts/MyCustomFont.woff2') format('woff2'),
        url('/fonts/MyCustomFont.woff') format('woff');

    font-weight: normal;
    font-style: normal;
}

Apply the custom font using the font-family property:

body {
    font-family: 'MyCustomFont', sans-serif;
}

Best Practices for Loading and Using Web Fonts
I. Performance Considerations:
Limit the number of fonts and font weights to reduce 
loading times.
Use font-display property to control how the browser 
renders text before the font loads (e.g., swap, fallback, 
optional).

II. Accessibility and Fallbacks:
Always include a fallback font in your font-family 
declarations to ensure text remains readable if the web 
font fails to load:

body {
    font-family: 'Roboto', Arial, sans-serif;
}

III. Font Loading Strategies:
Use the preconnect link to establish early connections, 
reducing load times:

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

Consider using a font loader library like Font Face 
Observer for more control over font loading and to 
avoid FOIT (Flash of Invisible Text).
https://github.com/bramstein/fontfaceobserver

IV. Legal Considerations:
Ensure you have the proper licensing for custom fonts, 
particularly for commercial projects.

By following these guidelines and understanding the options 
available, you can effectively enhance the visual appeal 
of your website with web fonts.




3. Colors and Background:
=========================

Text Colors
The color property in CSS allows you to change the 
color of the text within an element. Colors can be 
specified using several formats:

I. Named Colors: Using predefined color names.
p {
    color: red;
}

II. Hexadecimal Colors: 
A six-digit code that represents the red, green, 
and blue (RGB) components.
h1 {
    color: #ff5733;
}

III. RGB and RGBA Colors: 
RGB specifies the red, green, and blue components, 
while RGBA adds an alpha channel for opacity.

div {
    color: rgb(255, 87, 51);
}

span {
    color: rgba(255, 87, 51, 0.5);
}

IV. HSL and HSLA Colors: 
HSL stands for hue, saturation, and lightness, 
while HSLA includes the alpha channel for opacity.

a {
    color: hsl(9, 100%, 60%);
}

footer {
    color: hsla(9, 100%, 60%, 0.75);
}

Background Colors
The background-color property sets the background color 
of an element.

body {
    background-color: #f0f0f0;
}

section {
    background-color: rgba(0, 128, 128, 0.3);
}

Background Images and Gradients

Background Images
The background-image property is used to set a 
background image for an element.

header {
    background-image: url('header-bg.jpg');
}

You can also use multiple background images by 
separating them with commas.

main {
    background-image: 
        url('pattern.png'), 
        linear-gradient(to right, #333, #999);
}

Background Gradients
Gradients are a smooth transition between two or 
more colors and can be used as backgrounds. CSS 
supports linear and radial gradients.

I. Linear Gradients: 
Transitioning colors along a straight line.

.banner {
    background: linear-gradient(to right, #ff5733, #333);
}

II. Radial Gradients: 
Transitioning colors radiating from an origin point.

.circle {
    background: radial-gradient(circle, #ff5733, #333);
}

Controlling Background Size, Position, and Repeat

Background Size
The background-size property controls the size of 
the background image.

Cover: 
Scales the background image to cover the entire element.

.full-screen {
    background-size: cover;
}

Contain: 
Scales the image to fit within the element.

.thumbnail {
    background-size: contain;
}

Custom Size: 
Using specific dimensions or percentages.

.custom-size {
    background-size: 50% 50%;
}

Background Position

The background-position property sets the starting 
position of a background image.

.container {
    background-position: top left;
}

.card {
    background-position: 50% 50%;
}

Background Repeat
The background-repeat property controls how background 
images are repeated.

Repeat: 
The image is repeated both horizontally and vertically.

.tile {
    background-repeat: repeat;
}

No Repeat: 
The image is displayed once.

.single {
    background-repeat: no-repeat;
}

Repeat X or Y: 
The image is repeated horizontally (repeat-x) or 
vertically (repeat-y).

.repeat-horizontally {
    background-repeat: repeat-x;
}

.repeat-vertically {
    background-repeat: repeat-y;
}

By mastering the use of color and backgrounds, you 
can significantly enhance the visual appeal and 
readability of your web pages, creating a more 
engaging user experience.




4. List and Table Styling:
==========================

Styling Ordered and Unordered Lists

In CSS, both ordered and unordered lists can be 
styled to improve their appearance and enhance 
the user experience.

Basic List Styling
Ordered Lists (<ol>): 
These lists are numbered by default.

ol {
    list-style-type: decimal;
    margin-left: 20px;
}

Unordered Lists (<ul>): 
These lists use bullets by default.

ul {
    list-style-type: disc;
    margin-left: 20px;
}

Customizing List Markers
You can customize the appearance of list markers 
using the list-style-type and list-style-image 
properties.

Custom List Markers with list-style-type:

ul.square {
    list-style-type: square;
}

ol.alpha {
    list-style-type: lower-alpha;
}

Custom List Markers with Images:

ul.custom {
    list-style-image: url('path/to/marker.png');
}

Removing List Markers:

ul.nostyle {
    list-style-type: none;
}

Styling Tables
Tables can be styled extensively using CSS to enhance 
readability and design.

Basic Table Styling

Borders: 
Adding borders to a table and its cells.

table, th, td {
    border: 1px solid black;
    border-collapse: collapse;
}

Padding and Spacing: 
Adjusting padding inside cells and spacing between 
cells.

th, td {
    padding: 8px;
}

Advanced Table Styling

Table Alignment:

table {
    width: 100%;
    text-align: center;
}

Row and Column Styling:

tr:nth-child(even) {
    background-color: #f2f2f2;
}

th {
    background-color: #4CAF50;
    color: white;
}

Hover Effects:

tr:hover {
    background-color: #ddd;
}

Table Layout

Fixed Table Layout: 
Makes the table layout more predictable, useful 
for tables with large content.

table {
    table-layout: fixed;
}

th, td {
    width: 200px;
}

Caption Styling:

caption {
    caption-side: top;
    font-weight: bold;
    font-size: 1.2em;
    margin-bottom: 10px;
}

By mastering the styling of lists and tables, you can 
create well-organized and visually appealing web content 
that is easy for users to understand and navigate. 
These skills are essential for building clean, modern, 
and accessible web designs.




5. Text effects:
================

Text effects in CSS allow you to enhance the visual 
appearance of your text, making it more attractive 
and engaging. This lesson covers how to apply text 
shadows, outlines, and other advanced effects, and 
how to combine them for unique designs.

Text Shadows and Outlines

Text Shadows
The text-shadow property adds shadows to text, which 
can be used to create a sense of depth or highlight 
text.

Basic Text Shadow:

p.shadow {
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

This will apply a shadow 2px to the right and bottom 
of the text, with a blur radius of 4px and a color of 
semi-transparent black.

Multiple Text Shadows:

h1.multiple-shadows {
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5), -1px -1px 0 #fff;
}

This will apply a shadow with a white outline effect 
by combining two different shadows.

Text Outlines
CSS does not provide a specific property for text outlines. 
However, you can simulate an outline by applying multiple 
text-shadow properties.

h2.outline {
    text-shadow:
        1px 1px 0 #000,
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000;

    color: #fff;
}

This example creates a black outline around the text 
by adding shadows in all four directions.

Advanced Text Effects with CSS

Gradient Text
Applying gradients to text can create a modern, visually 
appealing effect.

h3.gradient-text {
  background: linear-gradient(to right, #ff7e5f, #feb47b);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

In this example, the text is filled with a gradient that 
transitions from one color to another.

Animated Text Effects
You can create animated text effects using CSS animations 
or transitions.

@keyframes rainbow {
    0% { color: red; }
    25% { color: orange; }
    50% { color: yellow; }
    75% { color: green; }
    100% { color: blue; }
}

h4.animated-text {
    animation: rainbow 5s infinite;
}

This will cycle through different colors, creating a 
rainbow effect on the text.

Combining Text Effects for Unique Designs
Combining multiple text effects can lead to unique and 
striking designs.

h5.combined-effects {
    text-shadow: 3px 3px 3px rgba(0, 0, 0, 0.3);
    background: linear-gradient(to right, #30cfd0, #330867);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: pulse 3s infinite;
}

@keyframes pulse {
    0%, 100% { text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.3); }
    50% { text-shadow: 5px 5px 5px rgba(0, 0, 0, 0.5); }
}

This example combines text shadows, gradient text, and 
an animated pulse effect to create a visually compelling 
and dynamic text design.

By mastering text effects, you can add a layer of 
sophistication and interest to your web pages, making 
the content more visually engaging and unique.




C. Layout and Positioning:


1. Display and Positioning:
===========================

Block Elements: 
Block-level elements take up the full width available, 
causing line breaks before and after the element. They 
start on a new line and stack vertically. Examples 
include <div>, <h1>, <p>, and <section>. By default, 
these elements have a top and bottom margin and can 
have their width and height explicitly set.

<div>This is a block-level element.</div>
<p>This paragraph is another block-level element.</p>

Inline Elements: 
Inline elements only take up as much width as necessary 
and do not start on a new line. They are displayed within 
the flow of the surrounding text. Examples include <span>, 
<a>, and <strong>. Inline elements respect the width and 
height of their content but do not allow for explicit 
width and height settings.

<span>This is an inline element.</span>
<a href="#">This link is also an inline element.</a>

Inline-Block Elements: 
Inline-block elements are similar to inline elements in 
that they do not break the flow of text, but they allow 
for width and height to be set, similar to block-level 
elements. Examples include <img>, and elements styled 
with display: inline-block;.

<img 
    src="example.jpg" 
    alt="Example Image" 
    style="display: inline-block; 
    width: 100px; 
    height: 100px;"
>


CSS Display Property and Its Values
display: 
The display property specifies how an element should be 
displayed on the page. It determines the layout behavior 
of an element.

block: 
The element is displayed as a block-level element, 
stacking vertically and taking up the full width 
available.

.block-element {
    display: block;
}

inline: 
The element is displayed as an inline element, 
flowing with text and only taking up as much 
width as necessary.

.inline-element {
    display: inline;
}

inline-block: 
The element is displayed as an inline-level block 
container, allowing width and height to be set while 
remaining within the text flow.

.inline-block-element {
    display: inline-block;
}

none: 
The element is removed from the document flow and does 
not occupy any space. It is not visible on the page.

.hidden-element {
    display: none;
}

flex: 
The element becomes a flex container, allowing for 
flexible layouts using Flexbox properties.

.flex-container {
    display: flex;
}

grid: 
The element becomes a grid container, enabling 
grid-based layout using Grid properties.

.grid-container {
    display: grid;
}

Understanding Positioning
static: 
The default positioning for elements. Elements are 
positioned according to the normal document flow. 
The top, right, bottom, and left properties have 
no effect.

.static-element {
    position: static;
}

relative: 
The element is positioned relative to its normal 
position. The top, right, bottom, and left properties 
can be used to offset the element from its original 
position.

.relative-element {
    position: relative;
    top: 10px;
    left: 20px;
}

absolute: 
The element is positioned relative to its nearest 
positioned ancestor (an ancestor  position set to 
anything other than static). If there is no such 
ancestor, it is positioned relative to the initial 
containing block. The top, right, bottom, and left 
properties determine the position.

.absolute-element {
    position: absolute;
    top: 50px;
    right: 20px;
}

fixed: 
The element is positioned relative to the viewport, 
so it stays in the same place even if the page is 
scrolled. The top, right, bottom, and left properties 
control its position.

.fixed-element {
    position: fixed;
    bottom: 10px;
    right: 10px;
}

sticky: 
The element is treated as relative until it crosses a 
specified threshold, at which point it is treated as 
fixed. It toggles between relative and fixed positioning 
depending on the scroll position.

.sticky-element {
    position: sticky;
    top: 0;
}

Example

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            .block-element {
                display: block;
                background-color: lightblue;
                padding: 10px;
            }

            .inline-element {
                display: inline;
                background-color: lightgreen;
                padding: 10px;
            }

            .inline-block-element {
                display: inline-block;
                background-color: lightcoral;
                width: 100px;
                height: 100px;
            }

            .relative-element {
                position: relative;
                top: 20px;
                left: 30px;
                background-color: lightgoldenrodyellow;
                padding: 10px;
            }

            .absolute-element {
                position: absolute;
                top: 50px;
                left: 50px;
                background-color: lightpink;
                padding: 10px;
            }

            .fixed-element {
                position: fixed;
                bottom: 20px;
                right: 20px;
                background-color: lightgray;
                padding: 10px;
            }

            .sticky-element {
                position: sticky;
                top: 0;
                background-color: lightsteelblue;
                padding: 10px;
            }
        </style>
    </head>

    <body>
        <div class="block-element">Block Element</div>
        <span class="inline-element">Inline Element</span>
        <div class="inline-block-element"></div>
        <div class="relative-element">Relative Element</div>
        <div class="absolute-element">Absolute Element</div>
        <div class="fixed-element">Fixed Element</div>
        <div class="sticky-element">Sticky Element</div>
    </body>
</html>

This content provides a detailed overview of the CSS 
display property and the different types of positioning 
used in web design.




2. Floating and Clearing:
=========================

The CSS float property is a powerful tool that allows 
elements to be pushed to the left or right, enabling 
text and inline elements to wrap around them. Floats 
are commonly used for creating simple layouts and 
positioning images or other content within a block 
of text.

float property values:
left: 
The element floats to the left side of its container, 
and content wraps around it on the right.

right: 
The element floats to the right side of its container, 
and content wraps around it on the left.

none: 
The element does not float (default).

inherit: 
The element inherits the float value from its parent.

Example: Using float for Image Alignment

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <style>
            .float-left {
                float: left;
                margin: 10px;
            }

            .float-right {
                float: right;
                margin: 10px;
            }
        </style>
    </head>

    <body>
        <img src="image.jpg" alt="Sample Image" class="float-left">
        <p>
            Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
            Vivamus lacinia odio vitae vestibulum vestibulum. Cras 
            venenatis euismod malesuada.
        </p>

        <img src="image.jpg" alt="Sample Image" class="float-right">
        <p>
            Donec nec justo eget felis facilisis fermentum. Aliquam 
            porttitor mauris sit amet orci. Aenean dignissim 
            pellentesque felis.
        </p>
    </body>
</html>

Clearing Floats and Containing Elements

Floats can affect the layout of surrounding elements, 
often causing their containers to collapse. To handle 
this, you can use the clear property or contain the 
floats within a parent element.

clear property values:
left:
Clears content on the left side of the element.

right:
Clears content on the right side of the element.

both:
Clears content on both sides.

none:
Default value; allows floating elements on both sides.

Example: Clearing Floats

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            .float-box {
                float: left;
                width: 150px;
                height: 150px;
                margin: 10px;
                background-color: lightblue;
            }
                
            .clear {
                clear: both;
            }
        </style>
    </head>
    <body>
        <div class="float-box">Box 1</div>
        <div class="float-box">Box 2</div>
        <div class="clear"></div>
        <p>This paragraph is below the floated boxes and will be pushed down because of the clearing.</p>
    </body>
</html>


Creating Simple Layouts with Floats

Floats are commonly used to create multi-column layouts by floating elements next to each other. Here’s a basic example of a two-column layout using floats:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        .container {
            width: 100%;
            overflow: hidden; /* Ensures the container recognizes floated elements */
        }
        .column {
            float: left;
            width: 48%;
            margin: 1%;
            background-color: lightcoral;
            padding: 20px;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="column">Column 1</div>
        <div class="column">Column 2</div>
    </div>
</body>
</html>


Key Takeaways:
Floats are a flexible way to position elements in a webpage and can be used for simple image positioning and creating multi-column layouts.

Clearing floats is necessary to prevent layout issues caused by the collapse of containing elements.

Floats, while useful, are not recommended for complex layout structures in modern web development; CSS Flexbox and Grid are better suited for such tasks.




3. Flexbox:
===========

Flexbox, short for Flexible Box Layout, is a powerful CSS layout module that provides an efficient way to lay out, align, and distribute space among items in a container. It is designed to provide a consistent layout on different screen sizes and devices.

Why Use Flexbox?
Simplifies complex layouts that are difficult to achieve with traditional CSS properties like float and positioning.

Allows for responsive design by adapting to different screen sizes.

Provides easy alignment and distribution of space between items in a container.

Flexbox Container and Items

To use Flexbox, you need a flex container that holds flex items. The container is set to display: flex; to activate the Flexbox layout for its child elements.

Flex Container Properties:

display: Defines a flex container (flex) or inline flex container (inline-flex).

flex-direction: Specifies the direction of the flex items (row, row-reverse, column, column-reverse).

flex-wrap: Controls whether flex items should wrap onto multiple lines (nowrap, wrap, wrap-reverse).

justify-content: Defines the alignment along the main axis (flex-start, flex-end, center, space-between, space-around, space-evenly).

align-items: Aligns flex items along the cross axis (stretch, flex-start, flex-end, center, baseline).

align-content: Aligns flex lines when there's extra space in the cross-axis (flex-start, flex-end, center, space-between, space-around, stretch).

Flex Item Properties:

order: Controls the order of the flex items.

flex-grow: Specifies how much a flex item will grow relative to the rest.

flex-shrink: Specifies how much a flex item will shrink relative to the rest.

flex-basis: Defines the default size of an element before the remaining space is distributed.

align-self: Overrides align-items for individual flex items.

Example: Basic Flexbox Layout

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        .flex-container {
            display: flex;
            flex-direction: row;
            justify-content: space-around;
            align-items: center;
            background-color: lightgrey;
            height: 200px;
        }
        .flex-item {
            background-color: lightcoral;
            padding: 20px;
            margin: 10px;
            width: 100px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="flex-container">
        <div class="flex-item">1</div>
        <div class="flex-item">2</div>
        <div class="flex-item">3</div>
    </div>
</body>
</html>


Common Flexbox Patterns and Layouts
Horizontal Centering: Easily center items horizontally with justify-content: center;.

Vertical Centering: Use align-items: center; to vertically align items within the container.

Responsive Navbars: Create navbars that adjust item positions as the screen size changes.

Equal Height Columns: Flex items naturally have equal height due to the Flexbox layout.

Complex Layouts: Combine different Flexbox properties for advanced layouts, such as galleries or form fields.

Example: Responsive Navbar

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        .navbar {
            display: flex;
            justify-content: space-between;
            background-color: #333;
            padding: 10px;
        }
        .nav-item {
            color: white;
            padding: 14px 20px;
            text-decoration: none;
        }
        .nav-item:hover {
            background-color: #ddd;
            color: black;
        }
    </style>
</head>
<body>
    <div class="navbar">
        <a href="#" class="nav-item">Home</a>
        <a href="#" class="nav-item">About</a>
        <a href="#" class="nav-item">Services</a>
        <a href="#" class="nav-item">Contact</a>
    </div>
</body>
</html>


Key Takeaways:
Flexbox is a flexible and powerful layout model ideal for creating responsive and adaptive web designs.

Mastering the use of Flexbox properties enables you to create layouts that are easy to manage and adapt across various devices.

Experimenting with different properties and their combinations will enhance your understanding and allow you to create advanced layout designs.




4. CSS Grid Layout:
===================


5. Responsive Design with Media Queries:
========================================




D. Advanced CSS Techniques



1. CSS Animations:
==================


2. CSS Transitions and Transforms:
==================================


3. Psudo classes and Pseudo elements:
=====================================


4. CSS Variables and Custom Properties:
=======================================


5. CSS Prepropressors:
======================



E. Performance and Optimization:


1. Minifying and Compressing CSS:
=================================


2. Critical CSS and Lazy loading:
=================================


3. Browser Compatibility and CSS:
=================================


4. Debugging CSS:
=================


5. Best Practices for Maintainable CSS:
=======================================








-->
