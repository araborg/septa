<!-- 
https://randoma11y.com/

A. Introduction to CSS:


1. What is CSS?
===============

CSS defines how elements should be rendered on the 
screen, in print, or by other media. It allows
developers to style web pages independently from 
the structure, (HTML).


History and Evolution of CSS
============================

CSS has evolved through various levels:

CSS1 (1996): The first official specification by 
the World Wide Web Consortium (W3C). It introduced 
basic styling features.

CSS2 (1998): Added new features like positioning, 
z-index, media types, and downloadable fonts.

CSS2.1 (2011): An update to CSS2 that refined and 
corrected the CSS2 specification.

CSS3 (Late 2000s-Present): Introduced modules allowing 
independent updates. Features include rounded corners, 
shadows, gradients, transitions, animations, and much 
more.

CSS4 (Ongoing): Rather than a single specification, 
CSS4 is more of a collection of modules that continue 
to evolve.


How CSS Integrates with HTML
============================

CSS integrates with HTML in three main ways:

1. Inline CSS: 
Styles are applied directly to HTML elements using the 
style attribute. 

Example:

<p 
    style="color: blue; font-size: 14px;"
>
    This is a blue paragraph.
</p>

2. Internal CSS: 
Styles are defined within the <style> element in the 
<head> section of an HTML document. 

Example:

<head>
    <style>
        p {
            color: green;
            font-size: 16px;
        }
    </style>
</head>

3. External CSS: 
Styles are written in a separate CSS file and linked 
to an HTML document using the <link> element. This is 
the most preferred way as it keeps HTML and CSS 
separate. 

Example:

<head>
    <link rel="stylesheet" type="text/css" href="styles.css">
</head>




2. CSS Syntax Selectors Properties
==================================
CSS syntax is structured into three main parts:

Selector: 
Identifies the HTML element(s) to be styled.

Property: 
Specifies the aspect of the element to be styled 
(e.g., color, font-size, margin).

Value: 
Defines the style for the property.

The basic structure of a CSS rule is:
selector {
    property: value;
}

For example:

p {
    color: red;
    font-size: 16px;
}

This rule applies to all <p> elements, setting their 
text color to red and font size to 16 pixels.

Basic Selectors:

Element Selector: 
Targets all instances of a given HTML element.

h1 {
    color: blue;
}

This rule changes the text color of all <h1> elements 
to blue.

Class Selector:
Targets elements with a specific class attribute. It 
is defined using a dot (.) followed by the class name.

.highlight {
    background-color: yellow;
}

This rule applies a yellow background to all elements 
with the class highlight.

ID Selector: 
Targets a single element with a specific ID attribute. 
It is defined using a hash (#) followed by the ID name.

#main-title {
    font-weight: bold;
}

This rule makes the text of the element with the ID 
main-title bold.


Grouping and Combining Selectors:

Grouping Selectors: 

Multiple selectors can be grouped to apply the same 
style to different elements.

h1, h2, h3 {
    color: green;
}

This rule applies a green color to all <h1>, <h2>, 
and <h3> elements.


Combining Selectors: 

You can combine selectors to target elements more 
specifically.

E.g:
Descendant Selector: div p {}

Child Selector: p > a {}

Adjacent Sibling Selector: h1 + h3

General Sibling Selector: h2 ~ p {}


Descendant Selector: div p {}
Targets elements INSIDE other elements.

ul li {
    color: purple;
}

This rule changes the text color of ALL <li> elements 
inside a <ul> to purple.


Child Selector: p > a {}
Targets immediate/direct child elements.

<div class="container">
    <p>This is a direct child paragraph.</p>

    <div>
        <p>This is a nested paragraph, not a direct child of .container.</p>
    </div>
</div>

container > p {
    font-style: italic;
}

This rule italicizes the text of <p> elements that is a 
direct children of a <div> with class container.

Adjacent Sibling Selector: h1 + h3
Targets elements immediately following a specified element.

<div class="container">
    <h2>Section Title</h2>
    <p>
        This is the first paragraph that is immediately after h2.
    </p>

    <p>This is the second paragraph.</p>

    <ul>
        <li>Item 1</li>
        <li>Item 2</li>
    </ul>
    
    <p>This is a paragraph after a list.</p>
</div>

h2 + p {
    margin-top: 20px;
}

This rule adds a 20-pixel top margin to d first <p> 
elements immediately following an <h2>.


General Sibling Selector: 
Targets all siblings following a specified element.

<div class="container">
    <h2>Main Heading</h2>

    <p>Paragraph 1</p>
    
    <div>Another Div</div>
    
    <p>Paragraph 2</p>
    
    <span>A Span</span>
    
    <p>Paragraph 3</p>
</div>

h2 ~ p {
    font-size: 14px;
}

This rule changes the font size of ALL <p> elements that 
follow an <h2>.




Methods of Applying CSS:
========================

There are three primary methods to apply CSS to HTML documents: 
inline, internal, and external. Each method serves different 
purposes and has its advantages and disadvantages.

I. Inline CSS:
CSS is applied directly to an HTML element using the style 
attribute.

Syntax:

<p style="color: blue; font-size: 14px;">
    This is a paragraph with inline CSS.
</p>

Advantages: 
Quick and useful for single-use styles or testing.

Disadvantages: 
Difficult to maintain and manage across large projects.

II. Internal CSS:
CSS is defined within the <style> tag inside the <head> 
section of an HTML document.

Syntax:

<head>
    <style>
        p {
            color: green;
            font-size: 16px;
        }
    </style>
</head>

Advantages:
Keeps CSS in one place, making it easier to manage than 
inline CSS.

Disadvantages: 
Styles are not reusable across multiple pages.

III. External CSS:
CSS is written in a separate file (with a .css extension) 
and linked to the HTML document using the <link> tag.

Syntax:

<head>
    <link rel="stylesheet" href="styles.css">
</head>

In styles.css:

p {
    color: red;
    font-size: 18px;
}

Advantages: 
Allows for reusability across multiple pages, making 
it the most efficient and maintainable method for 
large projects.

Disadvantages: 
Requires an additional file, which could potentially 
increase the number of HTTP requests.


The <style> Tag and <link> Tag

The <style> Tag:
Used for internal CSS.
Placed within the <head> section of the HTML document.

Allows you to define CSS styles directly within the HTML 
file.

Example:

<head>
    <style>
        body {
            background-color: lightgray;
        }
    </style>
</head>


The <link> Tag:
Used for external CSS.
Also placed within the <head> section.

Links an external CSS file to the HTML document.

Example:

<head>
    <link rel="stylesheet" href="main.css">
</head>


Best Practices for Organizing CSS

Modularity:
Break CSS into smaller, manageable files. For example, 
create separate CSS files for layout, typography, and 
components.

Commenting:
Use comments to explain sections of your CSS code, 
especially when styling is complex.

Consistent Naming Conventions:
Use meaningful class and ID names. Consider adopting 
a naming convention like BEM (Block, Element, Modifier) 
to enhance readability and maintainability.

Avoid Inline CSS:
Reserve inline CSS for testing or very specific, 
single-use cases.

Minimize Specificity:
Overly specific selectors can make CSS difficult to 
manage and override. Aim for less specificity when 
possible to maintain flexibility.

Keep It Organized:
Structure your CSS in a logical order, such as global 
styles, layout, components, utilities, etc.




CSS Units and Values:
=====================

CSS units and values are the building blocks of styling 
and positioning in web design. They define dimensions, 
colors, and various other attributes in a precise way. 

This lesson covers the essential units and values you'll
use frequently in your CSS.

Absolute:
Pixels (px): Border

Relative:
Em (em), Rem (rem): Typography
Percentage (%): Width, Height, Position


Understanding Length Units

I. Absolute Units:
Pixels (px): Border
A fixed unit, perfect for scenarios where you want precise 
control over the size. 

Ideal for borders, padding, and fixed dimensions.

Example: width: 200px;

Centimeters (cm), Millimeters (mm), Inches (in), Points (pt), 
Picas (pc): Rarely used in web design but available for 
precise print-style layouts.


II. Relative Units:
Em (em): Typography
Relative to the font size of the element's parent. 
Useful for scalable design, particularly typography.

Example: font-size: 2em; 
(twice the size of the parent’s font)

Rem (rem): Typography
Relative to the font size of the root element (<html>). 
Offers a consistent size across the entire document.

Example: font-size: 1.5rem; 
(1.5 times the root element’s font size)


Percentage (%): Width, Height, Position
Relative to the parent element's size. Commonly used for 
widths, heights, and positioning.

Example: width: 50%; (half the width of the parent)

Viewport Width (vw) and Viewport Height (vh): 
Percentage of the viewport's dimensions. 
Great for responsive design.

Example: width: 100vw; (full viewport width)

Viewport Min (vmin) and Viewport Max (vmax): 
Based on the smaller or larger dimension of the viewport, 
respectively.

Example: font-size: 3vmin; 
(3% of the smaller viewport dimension)

Color Values

I. Hexadecimal (#RRGGBB or #RGB):
A six-digit (or three-digit shorthand) hexadecimal notation. 
Each pair represents red, green, and blue.

Example: color: #ff0000; (red)

II. RGB (rgb(red, green, blue)):
Specifies colors using red, green, and blue components with 
values between 0 and 255.

Example: color: rgb(255, 0, 0); (red)

III. RGBA (rgba(red, green, blue, alpha)):
Similar to RGB, but includes an alpha channel for opacity. 
Alpha values range from 0 (completely transparent) to 1 
(completely opaque).

Example: color: rgba(255, 0, 0, 0.5); (red with 50% transparency)

IV. HSL (hsl(hue, saturation, lightness)):
Defines colors by hue (degree on the color wheel), 
saturation (percentage), and lightness (percentage).

Example: color: hsl(0, 100%, 50%); (red)

V. HSLA (hsla(hue, saturation, lightness, alpha)):
Extends HSL with an alpha channel for opacity.

Example: color: hsla(0, 100%, 50%, 0.5); (red with 50% 
transparency)


Other Common Values

I. Auto:
Allows the browser to automatically calculate the 
property’s value, commonly used with margins for 
centering elements.

Example: margin: auto;

II. Inherit:
Forces the property to inherit its value from its 
parent element.

Example: color: inherit;

III. Initial: i.e. Use Default Value
Sets the property to its default value.

Example: font-style: initial;

Summary
Understanding CSS units and values is crucial for 
creating flexible, responsive, and visually appealing 
web pages. By mastering these concepts, you’ll be able 
to make informed decisions about layout, typography, 
and color usage across your projects.




The Box Model:
==============

The CSS box model is a fundamental concept in web design 
that defines how elements are displayed and how they 
interact with each other. 

It encompasses the element’s content, padding, border, 
and margin. Understanding the box model is crucial for 
creating well-structured and responsive layouts.

Understanding the Box Model

I. Content:
This is the actual content of the box, such as text, 
images, or other elements. The size of the content can 
be controlled using the width and height properties.

II. Padding:
Padding is the space between the content and the border 
of the box. It can be set individually for each side 
(padding-top, padding-right, padding-bottom, padding-left) 
or all at once (padding).

Example: 

padding: 10px 20px; 
(10px top and bottom, 20px left and right)

III. Border
The border is the line around the padding and content. 
Like padding, it can be styled individually for each side 
or all at once. 

The border property includes the width, style, and color.

Example: 
border: 2px solid #000; 
(2px solid black border)

IV. Margin:
Margin is the space outside the border, separating the 
element from its neighbors. It can also be set individually 
or all at once.

Example: 
margin: 5px 10px; 
(5px top and bottom, 10px left and right) 

V. Width and Height:
By default, width and height apply only to the content 
of an element. Padding, borders, and margins are added 
outside these dimensions, potentially affecting the 
total size of the element.

Example: 
width: 200px; height: 100px;

VI. Box-Sizing:
The box-sizing property alters how the width and height 
properties are calculated.

Content-Box: 
This is the default value. The width and height properties 
include only the content, not padding, borders, or margins.

Border-Box: 
The width and height properties include the content, 
padding, and border, making it easier to set the size 
of an element without calculating these separately.

Example: box-sizing: border-box;


Working with Overflow and Visibility

I. Overflow:
The overflow property controls what happens when the 
content exceeds the dimensions of the box.

Visible: 
The overflow is not clipped; it renders outside the 
element’s box.

Hidden: 
The overflow is clipped, and the rest of the content 
will be invisible.

Scroll: 
Adds a scrollbar to see the overflow content

Auto: 
Adds a scrollbar only if needed.

Example: overflow: auto;

II. Visibility:
The visibility property determines whether an element is 
visible or hidden.

Visible: 
The element is visible (default).

Hidden: 
The element is not visible but still takes up space.
Example: visibility: hidden;


List 5 elements that are inline by default, and other
elements that are inline-block by default.




B. Text and Font Styling:

1. Font Properties:
===================
CSS offers various properties to define and control the 
appearance of text, making it an essential tool for web 
developers. Below are the key font properties:

I. font-family:
This property specifies the font to be used for an element. 
It accepts a list of font names, where the browser will use 
the first available font. For example:

p {
    font-family: Arial, Helvetica, sans-serif;
}

It is a good practice to include a generic font family at 
the end of the list for browsers that may not have the 
specific font installed.

II. font-size:
This property sets the size of the text. It can be defined 
using various units like pixels (px), em units (em), or 
percentages (%). For example:

p {
    font-size: 16px;
}

III. font-weight:
This property determines the boldness of the text. It can 
take values like normal, bold, bolder, lighter, or numeric 
values ranging from 100 to 900. For example:

p {
    font-weight: bold;
}

IV. font-style:
This property sets the style of the font, such as normal, 
italic, or oblique. For example:

p {
    font-style: italic;
}

Text Alignment, Decoration, and Transformation

I. Text Alignment:
The text-align property specifies the horizontal alignment 
of text in an element. It can take values such as left, 
right, center, or justify. For example:

p {
    text-align: center;
}

II. Text Decoration:
The text-decoration property adds decorations to text, such 
as underlines, overlines, or line-through. For example:

a {
    text-decoration: none;
}

III. Text Transformation:
The text-transform property controls the capitalization of 
text. It can be used to make text uppercase, lowercase, or 
capitalize the first letter of each word. For example:

p {
    text-transform: uppercase;
}

Line Height and Letter Spacing

I. Line Height:
The line-height the property specifies the space above and 
below inline elements. It helps to improve the readability 
of text by adjusting the vertical spacing between lines. 

For example:

p {
    line-height: 1.5;
}

II. Letter Spacing:
The letter-spacing property controls the space between 
characters in a text. It can be used to increase or 
decrease the spacing. For example:

p {
    letter-spacing: 2px;
}

Practical Application
To illustrate the combined use of these properties, 
consider the following example:

p {
    font-family: 'Roboto', sans-serif;
    font-size: 18px;
    font-weight: 400;
    font-style: normal;
    text-align: justify;
    text-decoration: underline;
    text-transform: capitalize;
    line-height: 1.6;
    letter-spacing: 1px;
}

This style rule sets a specific font with a moderate 
size and weight, italicizes the text, aligns it to 
the center, and applies a combination of line height 
and letter spacing to enhance readability. The text 
is capitalized with a thin line underneath, 
emphasizing a clean and modern appearance.




2. Working with Web Fonts:
==========================

Web fonts allow designers and developers to use fonts 
that aren't installed on the user's device. Instead, 
these fonts are downloaded from the web, providing 
more typography flexibility and enhancing the overall 
design of a website.

Why Use Web Fonts?
Consistency: 
Ensure the same font appears across all devices and 
browsers.

Design Variety: 
Choose from a vast selection of fonts to match the 
website's aesthetic.

Branding: 
Maintain brand consistency with specific fonts.

Using Google Fonts and Custom Fonts
Google Fonts is a popular and free web font library 
that offers a vast collection of fonts that are easy 
to integrate into your website.

A. Selecting a Font:
Visit Google Fonts and browse or search for fonts.
https://fonts.google.com/

Click on a font to view its details, styles, and 
character sets.

B. Embedding a Font:
Once you've chosen a font, click on the “Select 
this style” button.

On the sidebar, you’ll see a link tag that you can 
copy and paste into the <head> section of your HTML 
document:

<link 
    rel="stylesheet" 
    href="https://fonts.googleapis.com/css2?family=Roboto&display=swap"
>

C. Using the Font in CSS:
After embedding the font, apply it to your elements 
using the font-family property:

body {
    font-family: 'Roboto', sans-serif;
}

Custom Fonts
To use a custom font not available on Google Fonts or 
another library, you need to host the font files on 
your server.

I. Uploading the Font:
Upload the font files (usually .woff, .woff2, .ttf, 
or .otf formats) to your website’s directory.

II. Defining the Font in CSS:
Use the @font-face rule to define the custom font in 
your CSS:

@font-face {
    font-family: 'MyCustomFont';

    src: url('/fonts/MyCustomFont.woff2') format('woff2'),
        url('/fonts/MyCustomFont.woff') format('woff');

    font-weight: normal;
    font-style: normal;
}

Apply the custom font using the font-family property:

body {
    font-family: 'MyCustomFont', sans-serif;
}

Best Practices for Loading and Using Web Fonts
I. Performance Considerations:
Limit the number of fonts and font weights to reduce 
loading times.
Use font-display property to control how the browser 
renders text before the font loads (e.g., swap, fallback, 
optional).

II. Accessibility and Fallbacks:
Always include a fallback font in your font-family 
declarations to ensure text remains readable if the web 
font fails to load:

body {
    font-family: 'Roboto', Arial, sans-serif;
}

III. Font Loading Strategies:
Use the preconnect link to establish early connections, 
reducing load times:

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

Consider using a font loader library like Font Face 
Observer for more control over font loading and to 
avoid FOIT (Flash of Invisible Text).
https://github.com/bramstein/fontfaceobserver

IV. Legal Considerations:
Ensure you have the proper licensing for custom fonts, 
particularly for commercial projects.

By following these guidelines and understanding the options 
available, you can effectively enhance the visual appeal 
of your website with web fonts.




3. Colors and Background:
=========================

Text Colors
The color property in CSS allows you to change the 
color of the text within an element. Colors can be 
specified using several formats:

I. Named Colors: Using predefined color names.
p {
    color: red;
}

II. Hexadecimal Colors: 
A six-digit code that represents the red, green, 
and blue (RGB) components.
h1 {
    color: #ff5733;
}

III. RGB and RGBA Colors: 
RGB specifies the red, green, and blue components, 
while RGBA adds an alpha channel for opacity.

div {
    color: rgb(255, 87, 51);
}

span {
    color: rgba(255, 87, 51, 0.5);
}

IV. HSL and HSLA Colors: 
HSL stands for hue, saturation, and lightness, 
while HSLA includes the alpha channel for opacity.

a {
    color: hsl(9, 100%, 60%);
}

footer {
    color: hsla(9, 100%, 60%, 0.75);
}

Background Colors
The background-color property sets the background color 
of an element.

body {
    background-color: #f0f0f0;
}

section {
    background-color: rgba(0, 128, 128, 0.3);
}

Background Images and Gradients

Background Images
The background-image property is used to set a 
background image for an element.

header {
    background-image: url('header-bg.jpg');
}

You can also use multiple background images by 
separating them with commas.

main {
    background-image: 
        url('pattern.png'), 
        linear-gradient(to right, #333, #999);
}

Background Gradients
Gradients are a smooth transition between two or 
more colors and can be used as backgrounds. CSS 
supports linear and radial gradients.

I. Linear Gradients: 
Transitioning colors along a straight line.

.banner {
    background: linear-gradient(to right, #ff5733, #333);
}

II. Radial Gradients: 
Transitioning colors radiating from an origin point.

.circle {
    background: radial-gradient(circle, #ff5733, #333);
}

Controlling Background Size, Position, and Repeat

Background Size
The background-size property controls the size of 
the background image.

Cover: 
Scales the background image to cover the entire element.

.full-screen {
    background-size: cover;
}

Contain: 
Scales the image to fit within the element.

.thumbnail {
    background-size: contain;
}

Custom Size: 
Using specific dimensions or percentages.

.custom-size {
    background-size: 50% 50%;
}

Background Position

The background-position property sets the starting 
position of a background image.

.container {
    background-position: top left;
}

.card {
    background-position: 50% 50%;
}

Background Repeat
The background-repeat property controls how background 
images are repeated.

Repeat: 
The image is repeated both horizontally and vertically.

.tile {
    background-repeat: repeat;
}

No Repeat: 
The image is displayed once.

.single {
    background-repeat: no-repeat;
}

Repeat X or Y: 
The image is repeated horizontally (repeat-x) or 
vertically (repeat-y).

.repeat-horizontally {
    background-repeat: repeat-x;
}

.repeat-vertically {
    background-repeat: repeat-y;
}

By mastering the use of color and backgrounds, you 
can significantly enhance the visual appeal and 
readability of your web pages, creating a more 
engaging user experience.




4. List and Table Styling:
==========================

Styling Ordered and Unordered Lists

In CSS, both ordered and unordered lists can be 
styled to improve their appearance and enhance 
the user experience.

Basic List Styling
Ordered Lists (<ol>): 
These lists are numbered by default.

ol {
    list-style-type: decimal;
    margin-left: 20px;
}

Unordered Lists (<ul>): 
These lists use bullets by default.

ul {
    list-style-type: disc;
    margin-left: 20px;
}

Customizing List Markers
You can customize the appearance of list markers 
using the list-style-type and list-style-image 
properties.

Custom List Markers with list-style-type:

ul.square {
    list-style-type: square;
}

ol.alpha {
    list-style-type: lower-alpha;
}

Custom List Markers with Images:

ul.custom {
    list-style-image: url('path/to/marker.png');
}

Removing List Markers:

ul.nostyle {
    list-style-type: none;
}

Styling Tables
Tables can be styled extensively using CSS to enhance 
readability and design.

Basic Table Styling

Borders: 
Adding borders to a table and its cells.

table, th, td {
    border: 1px solid black;
    border-collapse: collapse;
}

Padding and Spacing: 
Adjusting padding inside cells and spacing between 
cells.

th, td {
    padding: 8px;
}

Advanced Table Styling

Table Alignment:

table {
    width: 100%;
    text-align: center;
}

Row and Column Styling:

tr:nth-child(even) {
    background-color: #f2f2f2;
}

th {
    background-color: #4CAF50;
    color: white;
}

Hover Effects:

tr:hover {
    background-color: #ddd;
}

Table Layout

Fixed Table Layout: 
Makes the table layout more predictable, useful 
for tables with large content.

table {
    table-layout: fixed;
}

th, td {
    width: 200px;
}

Caption Styling:

caption {
    caption-side: top;
    font-weight: bold;
    font-size: 1.2em;
    margin-bottom: 10px;
}

By mastering the styling of lists and tables, you can 
create well-organized and visually appealing web content 
that is easy for users to understand and navigate. 
These skills are essential for building clean, modern, 
and accessible web designs.




5. Text effects:
================

Text effects in CSS allow you to enhance the visual 
appearance of your text, making it more attractive 
and engaging. This lesson covers how to apply text 
shadows, outlines, and other advanced effects, and 
how to combine them for unique designs.

Text Shadows and Outlines

Text Shadows
The text-shadow property adds shadows to text, which 
can be used to create a sense of depth or highlight 
text.

Basic Text Shadow:

p.shadow {
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

This will apply a shadow 2px to the right and bottom 
of the text, with a blur radius of 4px and a color of 
semi-transparent black.

Multiple Text Shadows:

h1.multiple-shadows {
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5), -1px -1px 0 #fff;
}

This will apply a shadow with a white outline effect 
by combining two different shadows.

Text Outlines
CSS does not provide a specific property for text outlines. 
However, you can simulate an outline by applying multiple 
text-shadow properties.

h2.outline {
    text-shadow:
        1px 1px 0 #000,
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000;

    color: #fff;
}

This example creates a black outline around the text 
by adding shadows in all four directions.

Advanced Text Effects with CSS

Gradient Text
Applying gradients to text can create a modern, visually 
appealing effect.

h3.gradient-text {
  background: linear-gradient(to right, #ff7e5f, #feb47b);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

In this example, the text is filled with a gradient that 
transitions from one color to another.

Animated Text Effects
You can create animated text effects using CSS animations 
or transitions.

@keyframes rainbow {
    0% { color: red; }
    25% { color: orange; }
    50% { color: yellow; }
    75% { color: green; }
    100% { color: blue; }
}

h4.animated-text {
    animation: rainbow 5s infinite;
}

This will cycle through different colors, creating a 
rainbow effect on the text.

Combining Text Effects for Unique Designs
Combining multiple text effects can lead to unique and 
striking designs.

h5.combined-effects {
    text-shadow: 3px 3px 3px rgba(0, 0, 0, 0.3);
    background: linear-gradient(to right, #30cfd0, #330867);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: pulse 3s infinite;
}

@keyframes pulse {
    0%, 100% { text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.3); }
    50% { text-shadow: 5px 5px 5px rgba(0, 0, 0, 0.5); }
}

This example combines text shadows, gradient text, and 
an animated pulse effect to create a visually compelling 
and dynamic text design.

By mastering text effects, you can add a layer of 
sophistication and interest to your web pages, making 
the content more visually engaging and unique.




C. Layout and Positioning:


1. Display and Positioning:
===========================

Block Elements: 
Block-level elements take up the full width available, 
causing line breaks before and after the element. They 
start on a new line and stack vertically. Examples 
include <div>, <h1>, <p>, and <section>. By default, 
these elements have a top and bottom margin and can 
have their width and height explicitly set.

<div>This is a block-level element.</div>
<p>This paragraph is another block-level element.</p>

Inline Elements: 
Inline elements only take up as much width as necessary 
and do not start on a new line. They are displayed within 
the flow of the surrounding text. Examples include <span>, 
<a>, and <strong>. Inline elements respect the width and 
height of their content but do not allow for explicit 
width and height settings.

<span>This is an inline element.</span>
<a href="#">This link is also an inline element.</a>

Inline-Block Elements: 
Inline-block elements are similar to inline elements in 
that they do not break the flow of text, but they allow 
for width and height to be set, similar to block-level 
elements. Examples include <img>, and elements styled 
with display: inline-block;.

<img 
    src="example.jpg" 
    alt="Example Image" 
    style="display: inline-block; 
    width: 100px; 
    height: 100px;"
>


CSS Display Property and Its Values
display: 
The display property specifies how an element should be 
displayed on the page. It determines the layout behavior 
of an element.

block: 
The element is displayed as a block-level element, 
stacking vertically and taking up the full width 
available.

.block-element {
    display: block;
}

inline: 
The element is displayed as an inline element, 
flowing with text and only taking up as much 
width as necessary.

.inline-element {
    display: inline;
}

inline-block: 
The element is displayed as an inline-level block 
container, allowing width and height to be set while 
remaining within the text flow.

.inline-block-element {
    display: inline-block;
}

none: 
The element is removed from the document flow and does 
not occupy any space. It is not visible on the page.

.hidden-element {
    display: none;
}

flex: 
The element becomes a flex container, allowing for 
flexible layouts using Flexbox properties.

.flex-container {
    display: flex;
}

grid: 
The element becomes a grid container, enabling 
grid-based layout using Grid properties.

.grid-container {
    display: grid;
}

Understanding Positioning
static: 
The default positioning for elements. Elements are 
positioned according to the normal document flow. 
The top, right, bottom, and left properties have 
no effect.

.static-element {
    position: static;
}

relative: 
The element is positioned relative to its normal 
position. The top, right, bottom, and left properties 
can be used to offset the element from its original 
position.

.relative-element {
    position: relative;
    top: 10px;
    left: 20px;
}

absolute: 
The element is positioned relative to its nearest 
positioned ancestor (an ancestor  position set to 
anything other than static). If there is no such 
ancestor, it is positioned relative to the initial 
containing block. The top, right, bottom, and left 
properties determine the position.

.absolute-element {
    position: absolute;
    top: 50px;
    right: 20px;
}

fixed: 
The element is positioned relative to the viewport, 
so it stays in the same place even if the page is 
scrolled. The top, right, bottom, and left properties 
control its position.

.fixed-element {
    position: fixed;
    bottom: 10px;
    right: 10px;
}

sticky: 
The element is treated as relative until it crosses a 
specified threshold, at which point it is treated as 
fixed. It toggles between relative and fixed positioning 
depending on the scroll position.

.sticky-element {
    position: sticky;
    top: 0;
}

Example

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            .block-element {
                display: block;
                background-color: lightblue;
                padding: 10px;
            }

            .inline-element {
                display: inline;
                background-color: lightgreen;
                padding: 10px;
            }

            .inline-block-element {
                display: inline-block;
                background-color: lightcoral;
                width: 100px;
                height: 100px;
            }

            .relative-element {
                position: relative;
                top: 20px;
                left: 30px;
                background-color: lightgoldenrodyellow;
                padding: 10px;
            }

            .absolute-element {
                position: absolute;
                top: 50px;
                left: 50px;
                background-color: lightpink;
                padding: 10px;
            }

            .fixed-element {
                position: fixed;
                bottom: 20px;
                right: 20px;
                background-color: lightgray;
                padding: 10px;
            }

            .sticky-element {
                position: sticky;
                top: 0;
                background-color: lightsteelblue;
                padding: 10px;
            }
        </style>
    </head>

    <body>
        <div class="block-element">Block Element</div>
        <span class="inline-element">Inline Element</span>
        <div class="inline-block-element"></div>
        <div class="relative-element">Relative Element</div>
        <div class="absolute-element">Absolute Element</div>
        <div class="fixed-element">Fixed Element</div>
        <div class="sticky-element">Sticky Element</div>
    </body>
</html>

This content provides a detailed overview of the CSS 
display property and the different types of positioning 
used in web design.




2. Floating and Clearing:
=========================

The CSS float property is a powerful tool that allows 
elements to be pushed to the left or right, enabling 
text and inline elements to wrap around them. Floats 
are commonly used for creating simple layouts and 
positioning images or other content within a block 
of text.

float property values:
left: 
The element floats to the left side of its container, 
and content wraps around it on the right.

right: 
The element floats to the right side of its container, 
and content wraps around it on the left.

none: 
The element does not float (default).

inherit: 
The element inherits the float value from its parent.

Example: Using float for Image Alignment

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <style>
            .float-left {
                float: left;
                margin: 10px;
            }

            .float-right {
                float: right;
                margin: 10px;
            }
        </style>
    </head>

    <body>
        <img src="image.jpg" alt="Sample Image" class="float-left">
        <p>
            Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
            Vivamus lacinia odio vitae vestibulum vestibulum. Cras 
            venenatis euismod malesuada.
        </p>

        <img src="image.jpg" alt="Sample Image" class="float-right">
        <p>
            Donec nec justo eget felis facilisis fermentum. Aliquam 
            porttitor mauris sit amet orci. Aenean dignissim 
            pellentesque felis.
        </p>
    </body>
</html>

Clearing Floats and Containing Elements

Floats can affect the layout of surrounding elements, 
often causing their containers to collapse. To handle 
this, you can use the clear property or contain the 
floats within a parent element.

clear property values:
left:
Clears content on the left side of the element.

right:
Clears content on the right side of the element.

both:
Clears content on both sides.

none:
Default value; allows floating elements on both sides.

Example: Clearing Floats

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <style>
            .float-box {
                float: left;
                width: 150px;
                height: 150px;
                margin: 10px;
                background-color: lightblue;
            }
                
            .clear {
                clear: both;
            }
        </style>
    </head>

    <body>
        <div class="float-box">Box 1</div>
        <div class="float-box">Box 2</div>
        <div class="clear"></div>
        <p>
            This paragraph is below the floated boxes and 
            will be pushed down because of the clearing.
        </p>
    </body>
</html>


Creating Simple Layouts with Floats
Floats are commonly used to create multi-column layouts 
by floating elements next to each other. Here’s a basic 
example of a two-column layout using floats:

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <style>
            .container {
                width: 100%;
                overflow: hidden; /* Ensures the container recognizes floated elements */
            }

            .column {
                float: left;
                width: 48%;
                margin: 1%;
                background-color: lightcoral;
                padding: 20px;
                box-sizing: border-box;
            }
        </style>
    </head>

    <body>
        <div class="container">
            <div class="column">Column 1</div>
            <div class="column">Column 2</div>
        </div>
    </body>
</html>

Key Takeaways:
Floats are a flexible way to position elements in a webpage 
and can be used for simple image positioning and creating 
multi-column layouts.

Clearing floats is necessary to prevent layout issues caused 
by the collapse of containing elements.

Floats, while useful, are not recommended for complex 
layout structures in modern web development; CSS Flexbox 
and Grid are better suited for such tasks.




3. Flexbox:
===========

Flexbox, short for Flexible Box Layout, is a powerful 
CSS layout module that provides an efficient way to 
lay out, align, and distribute space among items in a 
container. It is designed to provide a consistent 
layout on different screen sizes and devices.

Why Use Flexbox?
Simplifies complex layouts that are difficult to achieve 
with traditional CSS properties like float and positioning.

Allows for responsive design by adapting to different 
screen sizes.

Provides easy alignment and distribution of space between 
items in a container.

Flexbox Container and Items
To use Flexbox, you need a flex container that holds flex 
items. The container is set to display: flex; to activate 
the Flexbox layout for its child elements.

Flex Container Properties:

display:
Defines a flex container (flex) or inline flex container 
(inline-flex).

flex-direction:
Specifies the direction of the flex items (row, row-reverse, 
column, column-reverse).

flex-wrap:
Controls whether flex items should wrap onto multiple 
lines (nowrap, wrap, wrap-reverse).

justify-content:
Defines the alignment along the main axis (flex-start, 
flex-end, center, space-between, space-around, 
space-evenly).

align-items:
Aligns flex items along the cross axis (stretch, flex-start, 
flex-end, center, baseline).

align-content:
Aligns flex lines when there's extra space in the cross-axis 
(flex-start, flex-end, center, space-between, space-around, 
stretch).

Flex Item Properties:

order: 
Controls the order of the flex items.

flex-grow: 
Specifies how much a flex item will grow relative to the 
rest.

flex-shrink: 
Specifies how much a flex item will shrink relative to 
the rest.

flex-basis: 
Defines the default size of an element before the 
remaining space is distributed.

align-self: 
Overrides align-items for individual flex items.

Example: Basic Flexbox Layout

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <style>
            .flex-container {
                display: flex;
                flex-direction: row;
                justify-content: space-around;
                align-items: center;
                background-color: lightgrey;
                height: 200px;
            }

            .flex-item {
                background-color: lightcoral;
                padding: 20px;
                margin: 10px;
                width: 100px;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <div class="flex-container">
            <div class="flex-item">1</div>
            <div class="flex-item">2</div>
            <div class="flex-item">3</div>
        </div>
    </body>
</html>


Common Flexbox Patterns and Layouts
Horizontal Centering: 
Easily center items horizontally with justify-content: center;.

Vertical Centering: 
Use align-items: center; to vertically align items within 
the container.

Responsive Navbars: 
Create navbars that adjust item positions as the screen 
size changes.

Equal Height Columns: 
Flex items naturally have equal height due to the Flexbox 
layout.

Complex Layouts: 
Combine different Flexbox properties for advanced layouts, 
such as galleries or form fields.

Example: Responsive Navbar

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <style>
            .navbar {
                display: flex;
                justify-content: space-between;
                background-color: #333;
                padding: 10px;
            }

            .nav-item {
                color: white;
                padding: 14px 20px;
                text-decoration: none;
            }

            .nav-item:hover {
                background-color: #ddd;
                color: black;
            }
        </style>
    </head>

    <body>
        <div class="navbar">
            <a href="#" class="nav-item">Home</a>
            <a href="#" class="nav-item">About</a>
            <a href="#" class="nav-item">Services</a>
            <a href="#" class="nav-item">Contact</a>
        </div>
    </body>
</html>


Key Takeaways:
Flexbox is a flexible and powerful layout model ideal 
for creating responsive and adaptive web designs.

Mastering the use of Flexbox properties enables you 
to create layouts that are easy to manage and adapt 
across various devices.

Experimenting with different properties and their 
combinations will enhance your understanding and 
allow you to create advanced layout designs.




4. CSS Grid Layout:
===================

CSS Grid Layout, or simply CSS Grid, is a two-dimensional 
layout system that allows developers to create complex and 
responsive grid-based layouts. Unlike Flexbox, which is 
primarily a one-dimensional layout model, CSS Grid is 
designed to handle both rows and columns simultaneously, 
making it perfect for creating intricate and detailed 
web layouts.

Why Use CSS Grid?
Provides a powerful and flexible way to create 
multi-dimensional layouts.

Offers extensive control over layout structure, including 
precise control of rows, columns, and spacing.

Enables easy rearrangement and responsiveness, adapting 
to different screen sizes.

Creating Grid-Based Layouts
To use CSS Grid, you define a grid container with the 
display: grid; property and then set up rows and columns 
using various grid properties.

Grid Container Properties:
display: 
Initiates a grid layout (grid) or inline grid (inline-grid).

grid-template-columns and grid-template-rows: 
Defines the number and size of columns and rows in the grid.

grid-gap, row-gap, and column-gap: 
Specifies the gap between rows and columns.

grid-template-areas: 
Assigns names to grid areas and lays out the structure in 
a simple manner.

justify-items and align-items: 
Aligns the grid items within their grid areas.

justify-content and align-content: 
Aligns the grid within the container when there's extra 
space.

Grid Item Properties:
grid-column-start, grid-column-end, grid-row-start, and grid-row-end: 
Specifies where an item starts and ends on the grid.

grid-area: 
Assigns a grid item to a named area or specifies its start 
and end points in both columns and rows.

justify-self and align-self: 
Overrides the container's alignment for individual grid items.

Example: Basic CSS Grid Layout

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <style>
            .grid-container {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                grid-template-rows: 200px 100px 100px;
                grid-gap: 10px;
                background-color: lightgrey;
            }

            .grid-item {
                background-color: lightcoral;
                padding: 20px;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <div class="grid-container">
            <div class="grid-item">1</div>
            <div class="grid-item">2</div>
            <div class="grid-item">3</div>
            <div class="grid-item">4</div>
            <div class="grid-item">5</div>
            <div class="grid-item">6</div>
        </div>
    </body>
</html>

Combining Grid and Flexbox for Complex Layouts
While CSS Grid excels at handling complex, multi-dimensional 
layouts, Flexbox is better suited for aligning items in 
one-dimensional layouts. Combining these two can result in 
highly responsive and adaptable designs.

Using Flexbox for Navigation and Headers:
Utilize Flexbox for sections that require horizontal or 
vertical alignment, such as headers or navigation bars.

Using CSS Grid for Main Content:
CSS Grid can be used to structure the main content area, 
allowing for a dynamic and fluid arrangement of elements.

Example: Combining Grid and Flexbox

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <style>
            .header {
                display: flex;
                justify-content: space-between;
                background-color: #333;
                padding: 10px;
            }

            .header-item {
                color: white;
                padding: 14px 20px;
                text-decoration: none;
            }

            .grid-container {
                display: grid;
                grid-template-columns: 1fr 3fr 1fr;
                grid-template-rows: auto 1fr;
                grid-gap: 10px;
                background-color: lightgrey;
            }

            .grid-item {
                background-color: lightcoral;
                padding: 20px;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <div class="header">
            <a href="#" class="header-item">Logo</a>
            <a href="#" class="header-item">Menu</a>
            <a href="#" class="header-item">Contact</a>
        </div>

        <div class="grid-container">
            <div class="grid-item">Sidebar</div>
            <div class="grid-item">Main Content</div>
            <div class="grid-item">Additional Info</div>
        </div>
    </body>
</html>

Key Takeaways:
CSS Grid is a versatile layout system capable of handling 
complex designs across rows and columns.

Understanding and using CSS Grid properties allow for 
precise control over layout and content placement.

Combining CSS Grid with Flexbox offers a powerful toolkit 
for building responsive, adaptive, and dynamic web pages.




5. Responsive Design with Media Queries:
========================================

Responsive design is an approach to web development where 
a website's layout adapts to different screen sizes and 
devices, ensuring an optimal viewing experience for users 
regardless of their device. This involves creating fluid 
layouts, and flexible images, and implementing CSS techniques 
like media queries to adjust the design based on the device's 
screen size.

Why Responsive Design?
Enhances user experience by providing a consistent look and 
feel across devices.

Improves accessibility by making content easily readable on 
all screen sizes.

Reduces maintenance and development costs by eliminating 
the need for multiple versions of a website.

Using Media Queries for Different Screen Sizes
Media queries are a CSS feature that allows developers to 
apply styles based on specific conditions, such as screen 
width, height, or device orientation. They are a cornerstone 
of responsive design, enabling layouts to adapt dynamically 
as the user’s viewport changes.

Basic Syntax of Media Queries
Media queries start with the @media rule followed by a 
condition and a block of CSS code to apply if the condition 
is met.

Example:

@media (max-width: 600px) {
    body {
        background-color: lightblue;
    }
}

Common Media Query Conditions
min-width and max-width: Target screens with a width 
greater than or less than the specified value.

min-height and max-height: Target screens with a height 
greater than or less than the specified value.

orientation: Target devices in landscape or portrait mode.

Example: Responsive Navigation Menu

<style>
    .nav {
        display: flex;
        justify-content: space-around;
        background-color: #333;
        padding: 10px;
    }

    .nav a {
        color: white;
        text-decoration: none;
        padding: 8px 16px;
    }

    @media (max-width: 600px) {
        .nav {
            flex-direction: column;
            align-items: center;
        }
    }
</style>

<div class="nav">
    <a href="#home">Home</a>
    <a href="#services">Services</a>
    <a href="#contact">Contact</a>
</div>

Responsive Units and Breakpoints
In responsive design, units and breakpoints play a 
crucial role in creating a fluid and adaptive layout. 
Understanding these concepts helps ensure designs work 
seamlessly across various devices.

Responsive Units
Percentage (%):
Useful for setting width, height, and margins relative 
to their parent element.

Viewport Width (vw) and Viewport Height (vh):
Represent a percentage of the viewport's width and height, 
respectively.

Relative Units (em, rem):
Scale based on the font size of the element (em) or 
the root element (rem).

Breakpoints
Breakpoints are specific points in the design where 
the layout changes to provide a better experience on 
different devices.

Common breakpoints include:
320px:
Small devices (mobile phones)

768px:
Medium devices (tablets)

1024px:
Large devices (small laptops)

1200px and above:
Extra-large devices (desktops and large screens)

Example:
Breakpoints in Action

@media (max-width: 768px) {
    .sidebar {
        display: none;
    }
}

@media (min-width: 769px) and (max-width: 1024px) {
    .content {
        width: 70%;
    }
}

@media (min-width: 1025px) {
    .content {
        width: 80%;
    }
}

Key Takeaways:
Responsive design ensures that websites are accessible 
and functional across a wide range of devices.

Media queries allow developers to apply specific CSS rules 
based on screen size and device characteristics.

Utilizing responsive units and well-defined breakpoints 
helps create adaptable layouts that provide an optimal 
viewing experience for users on any device.




D. Advanced CSS Techniques


1. CSS Animations:
==================

CSS animations are a powerful feature that allows you to 
animate the properties of HTML elements over time. With 
CSS animations, you can create dynamic and engaging 
effects without the need for JavaScript. This lesson will 
cover the basics of CSS animations, how to use keyframes, 
and best practices for creating smooth and effective 
animations.

Key Concepts

Animation Properties:
animation-name: 
The name of the @keyframes at-rule associated with the 
element.

animation-duration: 
How long does one cycle of the animation take to complete 
(e.g., 2s, 500ms).

animation-timing-function: 
The pace of the animation (e.g., linear, ease, ease-in, 
ease-out).

animation-delay: 
The amount of time to wait from applying the animation 
to starting it.

animation-iteration-count: 
How many times the animation will play (infinite for 
infinite loop).

animation-direction: 
The direction the animation should play (e.g., normal, 
reverse, alternate).

animation-fill-mode: 
How a CSS animation should apply styles to its target 
before and after it is executed (e.g., none, forwards, 
backwards, both).

animation-play-state: 
Specifies whether the animation is running or paused.


Keyframes and Animation Properties:

@keyframes: 
Defines the intermediate steps in a CSS animation 
sequence.

Usage Example:

@keyframes fadeIn {
    0% {
        opacity: 0;
    }

    100% {
        opacity: 1;
    }
}


Applying Animations:
You apply animations to elements using the animation 
property or individual animation properties.

Example:

.fading-element {
    animation-name: fadeIn;
    animation-duration: 2s;
    animation-iteration-count: infinite;
    animation-direction: alternate;
}


Creating Smooth Animations and Transitions

I. Transitions vs. Animations:

Transitions: 
Triggered by changes in properties (e.g., on hover), 
simpler, used for state changes.

Animations: 
Continuous and can loop, more complex, define multiple states.


II. Smooth Transitions:

Example:

.button {
    background-color: blue;
    transition: background-color 0.3s ease;
}

.button:hover {
    background-color: green;
}


I. Best Practices:

Keep Animations Subtle:
Avoid overly complex animations that could be distracting.

Performance:
Use hardware-accelerated properties like transform and 
opacity to keep animations smooth.

User Experience: 
Use animations to enhance user experience, such as 
providing feedback or guiding the user’s attention.


II. Combining Animations:

You can combine multiple animations by separating them 
with commas:

.combined-animations {
    animation: fadeIn 2s ease-in, slideIn 1s ease-out;
}




2. CSS Transitions and Transforms:
==================================

CSS transitions provide a way to control the speed of an 
animation when changing CSS properties. They are useful 
for creating simple animations triggered by events like 
hovering, focusing, or activating elements.

Transition Properties:
transition-property: Specifies the name of the CSS property 
the transition effect is for (e.g., width, background-color).

transition-duration: 
Specifies how many seconds or milliseconds a transition effect 
takes to complete.

transition-timing-function: 
Describes how the intermediate values of the CSS properties 
being affected by a transition effect are calculated (e.g., 
linear, ease, ease-in-out).

transition-delay: 
Specifies when the transition effect will start.


Basic Usage:

Example:

.box {
    width: 100px;
    height: 100px;
    background-color: blue;
    transition: width 2s, height 2s, background-color 2s;
}

.box:hover {
    width: 200px;
    height: 200px;
    background-color: green;
}


2D and 3D Transformations

Transformations allow you to rotate, scale, skew, or 
translate an element. They are powerful for creating 
dynamic and engaging visual effects.

I. 2D Transformations:

transform: 
Applies a 2D or 3D transformation to an element. This 
property allows you to manipulate the coordinate space 
of the CSS visual formatting model.

Types of 2D Transforms:
translate(x, y): 
Moves an element from its current position. translateX 
and translateY are specific versions for the x and y axes.

rotate(angle): 
Rotates the element clockwise from its current position.

scale(x, y): 
Changes the size of an element.

skew(x-angle, y-angle): 
Skews the element along the x and y axes.

Example:

.rotate-box {
    width: 100px;
    height: 100px;
    background-color: red;
    transform: rotate(45deg);
}


II. 3D Transformations:

Perspective: 
Defines how far the object appears to be from the viewer.

Types of 3D Transforms:
translateZ(z): 
Moves an element along the z-axis.

rotateX(angle), rotateY(angle), rotateZ(angle): 
Rotates the element around the respective axis.

scaleZ(z): 
Scales an element along the z-axis.

Example:

.cube {
    width: 100px;
    height: 100px;
    background-color: blue;
    transform: perspective(200px) rotateX(45deg) rotateY(45deg);
}


Practical Examples of Transitions and Transformations

I. Hover Effect:
A common use of transitions is to create smooth hover 
effects.

Example:

.hover-effect {
    width: 100px;
    height: 100px;
    background-color: pink;
    transition: transform 0.5s, background-color 0.5s;
}

.hover-effect:hover {
    transform: scale(1.2);
    background-color: purple;
}


II. 3D Card Flip:

Using 3D transforms to create a card flip effect.

Example:

.card {
    width: 200px;
    height: 300px;
    perspective: 1000px;
}

.card-inner {
    position: relative;
    width: 100%;
    height: 100%;
    text-align: center;
    transition: transform 0.6s;
    transform-style: preserve-3d;
}

.card:hover .card-inner {
    transform: rotateY(180deg);
}

.card-front, .card-back {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
}

.card-back {
    transform: rotateY(180deg);
    background-color: lightblue;
}




3. Psudo classes and Pseudo elements:
=====================================

Pseudo-classes and pseudo-elements are CSS selectors 
that enable you to style elements based on their state 
or to add special effects. They provide greater control 
and flexibility in styling your web pages, allowing you 
to target elements dynamically and add additional 
content or effects without modifying the HTML.

Pseudo-classes: 
A pseudo-class is used to define a special state of an 
element. For example, it can be used to style an element 
when a user hovers over it, or when an element is focused.

Pseudo-elements: 
A pseudo-element is used to style specific parts of 
an element or to insert content before or after an 
element. This allows for the creation of complex 
styles without additional HTML markup.


Common Pseudo-classes
Pseudo-classes help in targeting elements in specific 
states or positions within the DOM.

I. :hover: 
Styles an element when a user hovers over it with the 
cursor.

Example:

a:hover {
    color: blue;
    text-decoration: underline;
}

II. :focus: 
Styles an element when it has focus (usually by 
keyboard interaction).

Example:

input:focus {
    border-color: green;
    outline: none;
}

III. :nth-child(): 
Styles an element based on its position among its 
siblings.

Example:

li:nth-child(odd) {
    background-color: #f0f0f0;
}

IV. :active: 
Styles an element when it's being activated, such as when a button is clicked.

Example:

button:active {
  background-color: darkgray;
}

V. :visited: 
Styles a link that has been visited.

Example:

a:visited {
  color: purple;
}

VI. :not():
Styles elements that do not match a certain selector.

Example:

p:not(.highlight) {
  color: gray;
}

Styling with Pseudo-elements

Pseudo-elements are useful for adding extra styling details or inserting content.

I. ::before and ::after: 
Insert content before or after an element's content, respectively. They are commonly used for decorative purposes or adding visual elements.

Example:

.box::before {
  content: "Start";
  color: green;
}

.box::after {
  content: "End";
  color: red;
}

II. ::first-letter: 
Styles the first letter of an element.

Example:

p::first-letter {
  font-size: 2em;
  color: red;
}

III. ::first-line: 
Styles the first line of an element.

Example:

p::first-line {
  font-weight: bold;
  color: blue;
}

IV. ::selection: 
Styles the part of an element that has been selected by the user.

Example:

::selection {
  background-color: yellow;
  color: black;
}

V. ::marker: 
Styles the marker of a list item (e.g., bullet points or numbers in lists).

Example:

ul li::marker {
  color: orange;
}


Practical Usage Examples

Creating Decorative Quotes:

Use ::before and ::after to add decorative quotes.

Example:

blockquote::before, blockquote::after {
  content: '"';
  color: lightgray;
  font-size: 2em;
}

Button Ripple Effect:

Use :hover and ::after for a ripple effect.

Example:

.button:hover::after {
  content: "";
  position: absolute;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.3);
  animation: ripple 1s;
}

@keyframes ripple {
  0% { transform: scale(0); opacity: 1; }
  100% { transform: scale(4); opacity: 0; }
}




4. CSS Variables and Custom Properties:
=======================================

CSS variables, also known as custom properties, are 
entities defined by CSS authors that contain specific 
values to be reused throughout a document. CSS 
variables make it easier to maintain and update styles, 
especially when consistent theming or dynamic changes 
are required across multiple elements or pages.

Definition and Syntax:
CSS variables are defined with a custom property 
notation: --property-name.

They are accessed using the var() function.

Example:

:root {
    --primary-color: #3498db;
    --secondary-color: #2ecc71;
    --padding: 10px;
}


Advantages:

Maintainability: 
Changes to a single variable can update multiple 
elements.

Theming: 
Easy to switch themes by changing variable values.

Dynamic Styling: 
Can interact with JavaScript for runtime value 
changes.

Using Custom Properties for Theming
Custom properties are extremely useful for creating 
themes. By defining a set of variables at the root 
or top level, you can control the look and feel of 
the entire website by updating just a few lines of 
CSS.

Theming Example:

:root {
    --background-color: #ffffff;
    --text-color: #333333;
    --accent-color: #ff5733;
}

body {
    background-color: var(--background-color);
    color: var(--text-color);
}

a {
    color: var(--accent-color);
}

Switching Themes:

.dark-theme {
  --background-color: #1e1e1e;
  --text-color: #f5f5f5;
  --accent-color: #4caf50;
}

/* HTML */

/*
<body class="dark-theme">
    Content
</body>
*/

Advanced Use Cases of CSS Variables

Custom properties can be leveraged for more 
advanced scenarios beyond theming, including 
responsive design adjustments, animation 
control, and user interaction effects.

I. Responsive Design Adjustments:
Adjust variables based on media queries to change 
styles dynamically.

Example:

:root {
    --font-size: 16px;
}

@media (min-width: 768px) {
    :root {
        --font-size: 18px;
    }
}

body {
    font-size: var(--font-size);
}


II. Animation Control:
Use variables to control animation properties like duration, delay, and iteration.

Example:

:root {
  --animation-duration: 2s;
}

.box {
  animation: spin var(--animation-duration) infinite;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}


III. User Interaction Effects:
Change variable values on user interaction to update the UI dynamically.

Example:

:root {
  --button-color: #3498db;
}

button {
  background-color: var(--button-color);
  transition: background-color 0.3s;
}

button:hover {
  --button-color: #2ecc71;
}


Best Practices for Using CSS Variables
Define at the Root Level: Define your custom properties at the :root level when they apply to multiple components or global styling.

Fallback Values: Use fallback values in the var() function to ensure robustness in case a variable is not defined.

Example: color: var(--text-color, #000);

Organize Variables: Group related variables together and comment your CSS for clarity.

Avoid Overusing: While powerful, avoid using too many variables as it can complicate debugging and maintenance.




5. CSS Prepropressors:
======================




E. Performance and Optimization:


1. Minifying and Compressing CSS:
=================================


2. Critical CSS and Lazy loading:
=================================


3. Browser Compatibility and CSS:
=================================


4. Debugging CSS:
=================


5. Best Practices for Maintainable CSS:
=======================================








-->
