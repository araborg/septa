<!-- 
A. Introduction to JS
=====================

1. What is JavaScript?

Definition:
JavaScript is a high-level, interpreted programming
language primarily used to add interactivity to web
pages. It enables developers to create dynamic content
that can respond to user actions, such as clicks, 
input, or mouse movements.

Role in Web Development:
JavaScript is one of the core technologies of the web,
alongside HTML and CSS. While HTML provides the 
structure and CSS handles the styling, JavaScript is 
responsible for the behavior of web pages. It allows 
for the manipulation of the Document Object Model (DOM),
making it possible to update content, validate forms, 
create animations, and much more, without needing to 
reload the entire page.


2. Setting Up Your Development Environment

Introduction to Code Editors:
A code editor is a specialized text editor designed 
for writing and editing code, offering features like 
syntax highlighting, code completion, and debugging 
tools.

Popular code editors include Visual Studio Code (VS Code), 
Sublime Text, Atom, and others.

Key Features of Browser Developer Tools:

Console: 
A command-line interface to interact with JavaScript, log
information using console.log(), and debug scripts.

Elements Panel: 
Allows inspection and modification of HTML and CSS in 
real-time, understanding the Document Object Model (DOM), 
and testing code changes without editing source files.

Sources Panel: 
View, edit, and debug JavaScript files, set breakpoints, and 
step through code execution.

Network Panel: 
Monitor network requests and analyze loading times to optimize
performance.


3. JavaScript Basics

What Are Variables?
Variables are used to store data values in JavaScript. They 
act as containers that hold information that can be referenced 
and manipulated throughout your code.

Declaring Variables:
Variables in JavaScript can be declared using var, let, or 
const.

var: 
An older way to declare variables; 
function-scoped.

let: 
A modern way to declare variables; 
block-scoped.

const: 
Used to declare constants that cannot be reassigned; 
block-scoped.

Example:
var x = 10;      // Declares a variable x with value 10

let name = "Bob"; // Declares a block-scoped variable name 
with value "Bob"

const PI = 3.14; // Declares a constant PI with value 3.14

Data Types in JavaScript

Primitive Data Types:
String: 
Textual data enclosed in quotes (single or double).

Number: 
Numeric values (integers and floats).

Boolean: 
Represents true or false.

Undefined: 
A variable that has been declared but not assigned a value.

Null: 
Represents the intentional absence of any object value.

Symbol: 
Represents a unique and immutable value (introduced in ES6).

BigInt: 
For working with large integers.

Example of Data Types:

let age = 25;           // Number

let greeting = "Hello"; // String

let isStudent = false;  // Boolean

let city;               // Undefined

let salary = null;      // Null


Understanding Operators

Arithmetic Operators:
Perform basic mathematical operations.

+ Addition
- Subtraction
* Multiplication
/ Division
% Modulus (remainder)
** Exponentiation

Assignment Operators:
Assign values to variables.

= Assignment
+= Add and assign
-= Subtract and assign
*= Multiply and assign
/= Divide and assign

Comparison Operators:
Compare two values and return a Boolean (true or false).

== Equal to
=== Strictly equal (same value and type)

!= Not equal to
!== Strictly not equal

> Greater than
< Less than

>= Greater than or equal to
<= Less than or equal to

Logical Operators:
Combine multiple conditions.

&& Logical AND

|| Logical OR

! Logical NOT

Example of Using Operators:

let a = 10;
let b = 20;

let sum = a + b;           // 30 (Addition)
let isEqual = a == b;      // false (Comparison)
let bothTrue = (a < b) && (b > 15); // true (Logical)

Writing Simple Expressions and Statements

Expressions:
An expression is a combination of values, variables, and 
operators that produces a value.

Example:
let c = 5 * (2 + 3);  // c is assigned the value 25

Statements:
A statement is an instruction that performs an action.

Example:
let greeting = "Hello, World!"; // This is a statement

Introduction to Comments

Single-Line Comments:
Created using // at the beginning of the comment line.

Example:

// This is a single-line comment
let x = 10;  // This comment is at the end of a statement

Multi-Line Comments:
Created using /* to start and */ to end the comment block.

Example:

/* This is a
   multi-line comment */

let y = 20;

Best Practices for Writing Clean Code

Use Descriptive Variable Names:
Choose meaningful names that describe the purpose of the 
variable.

Example:
let totalPrice = 100;

Keep Code DRY (Don't Repeat Yourself):
Avoid duplicating code by using functions or loops.

Comment Wisely:
Use comments to explain complex logic, but avoid 
over-commenting.

Consistent Indentation:
Properly indent code to enhance readability.

Avoid Global Variables:
Minimize the use of global variables to prevent conflicts.


4. Control Flow:
is a fundamental concept in programming that determines the 
order in which statements and instructions are executed. In 
JavaScript, control flow allows you to make decisions, 
repeat tasks, and execute different blocks of code based on 
specific conditions. This lesson will explore the essential 
control flow structures in JavaScript: conditional statements 
and loops.

Conditional Statements:
are the backbone of decision-making in JavaScript. They allow 
your program to execute certain code blocks only when specific 
conditions are met. The main types of conditional statements 
in JavaScript include if, else if, else, and switch.

if Statement:
The if statement is the most basic form of conditional statement. 
It executes a block of code if the condition provided evaluates 
to true. If the condition is false, the code inside the if block 
is skipped.

Syntax:

if (condition) {
    // Code to execute if condition is true
}

Example:

let age = 18;

if (age >= 18) {
    console.log("You are eligible to vote.");
}

In this example, the condition age >= 18 is evaluated. Since the 
condition is true, the message "You are eligible to vote." is 
printed to the console.

else Statement:
The else statement complements the if statement. It allows you 
to define a block of code that will execute if the if condition 
evaluates to false. This provides a fallback option when the 
initial condition isn't met.

Syntax:

if (condition) {
    // Code to execute if condition is true
} else {
    // Code to execute if condition is false
}

Example:

let age = 16;

if (age >= 18) {
    console.log("You are eligible to vote.");
} else {
    console.log("You are not eligible to vote.");
}

Here, the condition age >= 18 is false, so the message "You 
are not eligible to vote." is printed.

else if Statement:
The else if statement allows you to test multiple conditions 
in sequence. If the first if condition is false, the program 
checks the next else if condition, and so on. This is useful 
for handling more than two possible outcomes.

Syntax:

if (condition1) {
    // Code to execute if condition1 is true
} else if (condition2) {
    // Code to execute if condition2 is true
} else {
    // Code to execute if all conditions are false
}

Example:

let score = 75;

if (score >= 90) {
    console.log("Grade: A");
} else if (score >= 80) {
    console.log("Grade: B");
} else if (score >= 70) {
    console.log("Grade: C");
} else if (score >= 60) {
    console.log("Grade: D");
} else {
    console.log("Grade: F");
}

In this example, the else if chain checks the score 
variable against multiple thresholds. The first 
condition that evaluates to true dictates the output, 
so "Grade: C" is printed.

Switch Statement:
The switch statement is a more organized way to compare 
a variable against multiple values. It's often used when 
you have a single variable that needs to be compared 
against several different cases. 

Each case in a switch statement is followed by a colon 
and the code to execute. 

The break statement is used to exit the switch block 
once a matching case is found.

Syntax:

switch (expression) {
    case value1:
        // Code to execute if expression === value1
        break;

    case value2:
        // Code to execute if expression === value2
        break;
        
        // Add more cases as needed

    default:
        // Code to execute if none of the cases match
}

Example:

let day = 3;
let dayName;

switch (day) {
    case 1:
        dayName = "Sunday";
        break;

    case 2:
        dayName = "Monday";
        break;

    case 3:
        dayName = "Tuesday";
        break;

    case 4:
        dayName = "Wednesday";
        break;

    case 5:
        dayName = "Thursday";
        break;

    case 6:
        dayName = "Friday";
        break;

    case 7:
        dayName = "Saturday";
        break;

    default:
        dayName = "Invalid day";
}

console.log(dayName);

In this example, the day variable is compared against 
each case. Since day equals 3, the dayName is set to 
"Tuesday", and this value is printed to the console.

The default case handles any values that don't match 
the listed cases.

Looping Structures:
Loops are used to repeat a block of code multiple times, 
depending on certain conditions. JavaScript provides three 
main types of loops: for, while, and do...while.

N.B: Three thgs that are impportant in loops
Initialization, 
Condition, and 
Increment/decrement

for Loop:
The for loop is a powerful and flexible loop structure that 
is used when you know how many times you want to iterate over 
a block of code. 

It consists of three parts: initialization, condition, and 
increment/decrement.

Syntax:

for (initialization; condition; increment) {
    // Code to be executed in each iteration
}

Example:

for (let i = 0; i < 5; i++) {
    console.log("Iteration number " + i);
}

In this example, the loop starts with i = 0 (initialization), 
runs as long as i < 5 (condition), and increments i by 1 after 
each iteration (i++). The loop will print the iteration number 
from 0 to 4.

while Loop:
The while loop is used when you want to repeat a block of code 
as long as a specified condition remains true. 

Unlike the for loop, the while loop does not have a built-in 
counter, so you need to manage the loop's control variable 
manually.

Syntax:

while (condition) {
    // Code to be executed as long as condition is true
}

Example:

let i = 0; // initialization; 

while (i < 5) { // condition; 
    console.log("Iteration number " + i);

    i++; // increment;
}

In this example, the loop runs as long as i < 5. The variable 
i is incremented with each iteration, printing numbers 0 to 4. 
The loop stops when i equals 5.

do...while Loop:
The do...while loop is similar to the while loop, but with a 
key difference: it guarantees that the code block inside the 
loop is executed at least once, even if the condition is false 
from the start. 

This is because the condition is checked after the loop has run.

Syntax:

do {
    // Code to be executed
} while (condition);


Example:

let i = 0;

do {
    console.log("Iteration number " + i);

    i++;
} while (i < 5);

In this example, the loop will print numbers 0 to 4, just 
like the previous loops. However, even if i started with 
a value of 5, the loop would still execute once before 
checking the condition.

Breaking and Continuing Loops
JavaScript provides two special statements to control the 
flow of loops: break and continue. They r majorly used 
in LOOPS.

break Statement:
The break statement is used to exit a loop immediately, 
regardless of the loop's condition. This is useful when 
you need to stop the loop early based on a specific 
condition.

Example:

for (let i = 0; i < 10; i++) {
    if (i === 5) {
        break; // Exit the loop when i equals 5
    }

    console.log(i);
}

In this example, the loop will print numbers from 0 to 4. 
When i equals 5, the break statement terminates the loop, 
so the loop does not continue to 10.

continue Statement:
The continue statement skips the current iteration of the 
loop and moves on to the next iteration. This is useful 
when you want to skip over certain values or conditions 
without stopping the loop entirely.

Example:

for (let i = 0; i < 10; i++) {
    if (i === 5) {
        continue; // Skip the iteration when i equals 5
    }

    console.log(i);
}

In this example, the loop prints numbers from 0 to 9, except 
for 5. When i equals 5, the continue statement causes the 
loop to skip that iteration, so 5 is not printed.


5. Functions

Functions are a foundational concept in JavaScript. They allow 
you to encapsulate blocks of code that can be reused throughout 
your program, making your code more modular, readable, and 
maintainable. In this lesson, we'll dive into defining functions, 
invoking them, using parameters and return values, and 
understanding the scope of variables within functions.

Defining and Invoking Functions

Defining a Function:
A function in JavaScript is defined using the function keyword, 
followed by a name, a list of parameters (optional), and a block 
of code that the function will execute.

Syntax:

function functionName(parameters) {
    // Code to be executed
}

Example:

function greet() {
    console.log("Hello, world!");
}

In this example, we've defined a function named greet that, 
when called, will print "Hello, world!" to the console.

Invoking a Function
To execute the code within a function, you need to invoke 
(or call) the function by using its name followed by 
parentheses.

Example:

greet(); // Outputs: Hello, world!

Here, the greet function is invoked, and the message 
"Hello, world!" is printed to the console.

Function Parameters and Return Values:

Parameters:
Parameters are inputs that you can pass to a function to 
customize its behavior. They act as placeholders for the 
values that will be passed to the function when it is 
invoked.

Example:

function greetUser(name) {
    console.log("Hello, " + name + "!");
}

greetUser("Alice"); // Outputs: Hello, Alice!

In this example, the greetUser function accepts a parameter, 
name, and uses it to personalize the greeting.

Return Values:
A function can also return a value to the code that called 
it, using the return statement. This allows the function to 
produce an output that can be stored in a variable or used 
in other parts of your program.

Example:

function add(a, b) {
    return a + b;
}

let sum = add(5, 3); // sum will be 8

console.log(sum); // Outputs: 8

Here, the add function takes two parameters, a and b, adds 
them together, and returns the result. The returned value 
is then stored in the variable sum.

Understanding Scope:

Scope determines the visibility and accessibility of variables 
within different parts of your program. JavaScript has two 
main types of scope: local and global.

Local Scope:
A variable declared inside a function has local scope, meaning 
it is only accessible within that function.

Example:

function multiply(x, y) {
    let result = x * y;
    
    return result;
}

console.log(result); // Error: result is not defined

In this example, the result variable is declared inside the 
multiply function, so it is not accessible outside the 
function.

Global Scope:
A variable declared outside any function has global scope, 
meaning it is accessible throughout your entire program.

Example:

let globalVar = "I am global";

function showGlobalVar() {
    // inside showGlobalVar fxn
    console.log(globalVar);
}

// outside showGlobalVar fxn
showGlobalVar(); // Outputs: I am global

Here, globalVar is accessible both inside and outside the 
showGlobalVar function because it is globally scoped.

Best Practices for Writing Functions
Keep functions small and focused: 
Each function should perform a single task or a small set 
of closely related tasks. This makes your functions easier 
to understand, test, and reuse.

Use meaningful names: 
Function names should clearly describe what the function does. 
This makes your code more readable.

Avoid side effects: 
Functions should avoid modifying variables or states outside 
their scope unless absolutely necessary. This reduces unintended 
consequences and bugs.

Document your functions: 
Include comments or documentation to explain what each function 
does, what parameters it takes, and what it returns.

By mastering functions, you'll be able to write more efficient, 
modular, and maintainable JavaScript code. Functions are a 
powerful tool in your programming toolbox, and understanding 
them deeply will greatly enhance your ability to build complex 
applications.


B. Working With Data In JS
==========================

1. Arrays

Introduction to Arrays:
An array in JavaScript is a special type of object used 
to store multiple values in a single variable. 

Arrays are ordered collections, meaning each item has a 
specific position (index) within the array. 

They are incredibly versatile and are used extensively in 
JavaScript programming for managing lists of data.

Creating Arrays
There are two main ways to create an array in JavaScript:

1. Array Literal Notation: 
This is the most straightforward way to create an array. You 
simply enclose a comma-separated list of values in square 
brackets.

Example:
let fruits = ['apple', 'banana', 'orange'];

2. Array Constructor: 
You can also use the Array() constructor to create an array. 
This method is less common but can be useful in certain 
situations.

Example:
let numbers = new Array(1, 2, 3, 4, 5);

Accessing Array Elements:
Array elements are accessed using their index. 

In JavaScript, array indices start at 0. This means the first 
element is at index 0, the second at index 1, and so on.

Example:
let fruits = ['apple', 'banana', 'orange'];

console.log(fruits[0]); // Outputs: 'apple'
console.log(fruits[2]); // Outputs: 'orange'

Array Properties and Basic Methods:

length Property: 
The length property returns the number of elements in an array.

Example:
let fruits = ['apple', 'banana', 'orange'];

console.log(fruits.length); // Outputs: 3

push() Method: 
The push() method adds one or more elements to the end of 
an array and returns the new length of the array.

Example:
let fruits = ['apple', 'banana'];
fruits.push('orange');

console.log(fruits); // Outputs: ['apple', 'banana', 'orange']

console.log(fruits.push('orange')); // 3

let fruits = ['apple', 'banana'];
const addFruit = fruits.push('orange');
console.log(addFruit)// 3

pop() Method: 
The pop() method removes the last element from an array 
and returns that element.

Example:
let fruits = ['apple', 'banana', 'orange'];
let lastFruit = fruits.pop();

console.log(lastFruit); // Outputs: 'orange'
console.log(fruits); // Outputs: ['apple', 'banana']

Array Manipulation:

Adding Elements: using index
Besides push(), you can add elements to specific positions 
using the index:

let fruits = ['apple', 'banana'];
fruits[2] = 'orange'; // Adds 'orange' at index 2
fruits[10] = 'grape'; // Creates empty slots and adds 'grape' at index 10

console.log(fruits) 
// [ "apple", "banana", "orange", <7 empty slots>, "grape"]

Removing Elements: 
The splice() method can be used to remove elements from 
any position in the array:

let fruits = ['apple', 'banana', 'orange', 'grape'];
fruits.splice(1, 2); // Removes 2 elements starting from index 1 or From
index 1 remove 2 elements

console.log(fruits); // Outputs: ['apple', 'grape']

Iterating Through Arrays:
There are several ways to iterate through arrays in JavaScript:

for Loop: 
The traditional for loop is often used for array iteration.

Example:

let fruits = ['apple', 'banana', 'orange'];

for (let i = 0; i < fruits.length; i++) {
    console.log(fruits[i]);
}

forEach() Method: 
The forEach() method executes a provided function once for 
each array element.

Example:

let fruits = ['apple', 'banana', 'orange'];

fruits.forEach(
    function(fruit) {
        console.log(fruit);
    }
);

for...of Loop: 
Introduced in ES6, the for...of loop provides a simpler 
syntax for iterating over iterable objects like arrays.
i.e arrays can also be called Objects?

Example:

let fruits = ['apple', 'banana', 'orange'];

for (let fruit of fruits) {
    console.log(fruit);
}

Common Array Methods

map(): 
The map() method creates a new array with the results of 
calling a provided function on every element in the array.

Example:

let numbers = [1, 2, 3, 4, 5];

let squared = numbers.map(
    function(num) {
        return num * num;
    }
);

console.log(squared); // Outputs: [1, 4, 9, 16, 25]

filter(): 
The filter() method creates a new array with all elements 
that pass the test implemented by the provided function.

Example:

let numbers = [1, 2, 3, 4, 5, 6];

let evenNumbers = numbers.filter(
    function(num) {
        return num % 2 === 0;
    }
);

console.log(evenNumbers); // Outputs: [2, 4, 6]

reduce(): 
The reduce() method executes a reducer function on each 
element of the array, resulting in a single output value.

Example:

let numbers = [1, 2, 3, 4, 5];

let sum = numbers.reduce(
    function(accumulator, currentValue) {
        return accumulator + currentValue;
    }, 0
);

console.log(sum); // Outputs: 15

Understanding arrays and their methods is crucial in 
JavaScript programming. They provide powerful tools for 
managing and manipulating collections of data efficiently. 
Practice working with arrays and their methods to become 
proficient in using them in your JavaScript programs.


2. Objects

Introduction to Objects and Key-Value Pairs:

Objects are one of the most fundamental and powerful concepts 
in JavaScript. They allow you to store collections of related 
data and functionality in a single container. 

Unlike arrays, which use numeric indices, objects use keys 
to access their members.

An object in JavaScript is a collection of key-value pairs. 

Each key-value pair is called a property:

The key is always a string (or a Symbol in ES6+).

The value can be any valid JavaScript data type, including 
numbers, strings, arrays, functions, and even other objects.

Basic Object Syntax
Here's the basic syntax for creating an object:

let person = {
    name: "John Doe",
    age: 30,
    isStudent: false
};

In this example:
person is the object

name, age, and isStudent are keys (also called property 
names)

"John Doe", 30, and false are the corresponding (property) 
values

Creating and Accessing Object Properties

Creating Objects:
There are several ways to create objects in JavaScript:

1. Object Literal Notation (as shown above):

let car = {
    brand: "Toyota",
    model: "Corolla",
    year: 2022
};

console.log(car)
// Object { brand: "Toyota", model: "Corolla", year: 2022 }

2. Using the new Keyword with Object() Constructor:

let bike = new Object();
bike.type = "Mountain Bike";
bike.gears = 21;

console.log(bike)
// Object { type: "Mountain Bike", gears: 21 }

3. Using Object Constructor Functions:

function Book(title, author) {
    this.title = title;
    this.author = author;
}

let myBook = new Book("1984", "George Orwell");

console.log(myBook) 
// Object { title: "1984", author: "George Orwell" }

Accessing Object Properties:

There are two main ways to access object properties:

Dot Notation:
console.log(car.brand);  // Outputs: Toyota

Bracket Notation:
console.log(car["model"]);  // Outputs: Corolla

Bracket notation is particularly useful when:
- The property name is stored in a variable
- The property name has special characters or starts with 
a number.
- The property name is refrenced as a string unless stored
as a variable.

car["model"]
car[propertyName]: propertyName being a variable.

Example:

let propertyName = "year";
console.log(car[propertyName]);  // Outputs: 2022

Adding and Modifying Properties
You can add new properties or modify existing ones after 
an object is created:

car.color = "blue";  // Adds a new property
car.year = 2023;     // Modifies an existing property


Deleting Properties
You can remove a property from an object using the delete 
operator:

delete car.color;
console.log(car.color);  // Outputs: undefined

Methods (Fxns) Within Objects:

Methods are functions that are stored as object properties. 
They define the behavior of an object.

Defining Methods
You can define a method when creating an object:

let person = {
    name: "Alice",

    greet: function() {
        console.log("Hello, I'm " + this.name);
        // note d name property is referred to as this.name
        // ds is the same as person.name
    }
};

person.greet();  // Outputs: Hello, I'm Alice

In ES6+, you can use a shorter syntax:

let person = {
    name: "Alice",

    greet() {
        console.log("Hello, I'm " + this.name);
    }
};

object methods:
greet: function() {} 
    or
greet() {}

The "this" Keyword:
In the context of an object method, "this" refers to 
the object the method belongs to. 

It allows methods to access and manipulate the object's 
properties (key-value pairs).

let calculator = {
    value: 0,

    add(x) {
        this.value += x;
    },

    subtract(x) {
        this.value -= x;
    },

    getValue() {
        return this.value;
    }
};

calculator.add(5); // value = 5
calculator.subtract(2); // value = 5 - 2 gives 3
console.log(calculator.getValue());  // Outputs: 3

Object Destructuring:
ES6 introduced object destructuring, which provides a 
concise way to extract values from objects and assign 
them to variables:

let person = {
    name: "John",
    age: 30,
    city: "New York"
};

let { name, age } = person;

console.log(name);  // Outputs: John
console.log(age);   // Outputs: 30

You can also assign to different variable names:

let { name: personName, age: personAge } = person;

console.log(personName);  // Outputs: John
console.log(personAge);   // Outputs: 30

Conclusion:
Objects are a cornerstone of JavaScript programming. They 
allow you to create complex data structures, organize your 
code, and model real-world entities in your programs. 

Understanding how to create, access, and manipulate objects 
is crucial for becoming proficient in JavaScript.

In the next lessons, we'll explore more advanced object 
concepts, including prototypes, inheritance, and ES6 
classes.


3. Working with Strings

Introduction to Strings in JavaScript:

In JavaScript, a string is a sequence of characters used 
to represent text. Strings are one of the fundamental data 
types in JavaScript and are used extensively in web 
development for tasks such as displaying text on a webpage, 
processing user input, and manipulating textual data.

Creating Strings:
There are three ways to create strings in JavaScript:

1. Single quotes:
let singleQuoted = 'Hello, World!';

2. Double quotes:
let doubleQuoted = "Hello, World!";

3. Template literals (backticks):
let templateLiteral = `Hello, World!`;

Single and double quotes are functionally identical. Template 
literals, introduced in ES6, offer more flexibility, allowing 
for multi-line strings and string interpolation.

String Properties:

Length:
The length property returns the number of characters in a 
string.

Example:

let text = "Hello";
console.log(text.length); // Outputs: 5

String Methods:

JavaScript provides numerous built-in methods for manipulating 
and working with strings. Here are some of the most commonly 
used ones:

1. indexOf() and lastIndexOf():
These methods search for a specified substring within a string 
and return its position.

indexOf(): 
Searches from the beginning of the string.

lastIndexOf(): 
Searches from the end of the string.

Both return -1 if the substring is not found.

Example:

let str = "Hello, World!";
console.log(str.indexOf("o"));    // Outputs: 4
console.log(str.lastIndexOf("o")); // Outputs: 7

2. slice():
The slice() method extracts a portion of a string 
and returns it as a new string, without modifying 
the original string.

Syntax: str.slice(startIndex, endIndex)

Example:

let str = "Hello, World!";

console.log(str.slice(7, 12)); // Outputs: "World"
console.log(str.slice(7));     // Outputs: "World!"

3. substring():
Similar to slice(), but doesn't support negative indexes
and swaps arguments if startIndex is greater than 
endIndex.

Example:

let str = "Hello, World!";
console.log(str.substring(7, 12)); // Outputs: "World"

4. toLowerCase() and toUpperCase():
These methods convert a string to lowercase or uppercase 
respectively.

Example:

let str = "Hello, World!";
console.log(str.toLowerCase()); // Outputs: "hello, world!"
console.log(str.toUpperCase()); // Outputs: "HELLO, WORLD!"

5. trim():
The trim() method removes whitespace from both ends of a 
string.

Example:

let str = "   Hello, World!   ";
console.log(str.trim()); // Outputs: "Hello, World!"

6. replace():
The replace() method replaces a specified value with another
value in a string.

Example:

let str = "Hello, World!";

console.log(str.replace("World", "JavaScript")); 
// Outputs: "Hello, JavaScript!"

Note: 
By default, replace() only replaces the first occurrence. To 
replace all occurrences, use a regular expression with the 
global flag.

Template Literals and String Interpolation:
Template literals, introduced in ES6, provide an easy way 
to create multi-line strings and to interpolate variables 
and expressions into strings.

Example:

let name = "Alice";
let age = 30;

let greeting = `Hello, my name is ${name} and I am ${age} years old.`;

console.log(greeting);
// Outputs: "Hello, my name is Alice and I am 30 years old."

Regular Expressions for Pattern Matching:
Regular expressions (regex) are powerful tools for pattern 
matching and manipulation of strings. In JavaScript, you 
can create a regular expression using the RegExp constructor 
or regex literal notation.

Example:

// Using regex literal
let pattern = /hello/i;  // 'i' flag makes it case-insensitive

// Using RegExp constructor
let pattern = new RegExp("hello", "i");

let str = "Hello, World!";
console.log(pattern.test(str));  // Outputs: true

Common regex methods:

test(): 
Returns true if there's a match, false otherwise.

exec(): 
Returns an array of information if there's a match, or 
null otherwise.

match(): 
When used with a string, returns an array of matches.

Example of using regex with string methods:

let str = "The rain in Spain falls mainly in the plain";

let matches = str.match(/ain/g);
console.log(matches);  // Outputs: ["ain", "ain", "ain"]

Understanding how to work with strings effectively is 
crucial in JavaScript programming. Strings are used in 
almost every aspect of web development, from manipulating 
DOM content to processing user input and working with 
APIs. Regular practice with these methods and concepts 
will greatly enhance your ability to handle textual data 
in your JavaScript applications.


4. Numbers and Math

Understanding JavaScript Number Types:

In JavaScript, all numbers are represented as 64-bit 
floating-point numbers, following the IEEE 754 standard. 

This means that JavaScript doesn't distinguish between 
integers and floating-point numbers - they're all treated 
as one number type.

Key points about JavaScript numbers:

1. No separate integer type: 
Unlike some other programming languages, JavaScript doesn't 
have a separate type for integers.

2. Precision limitations: 
Due to the floating-point representation, some decimal 
numbers can't be represented exactly, which can lead 
to precision errors in calculations.

3. Special number values: 
JavaScript has special number values like Infinity, 
-Infinity, and NaN (Not a Number).

Example:

let integer = 42;
let float = 3.14159;
let scientific = 5e3; // 5000 in scientific notation

console.log(typeof integer);  // Outputs: "number"
console.log(typeof float);    // Outputs: "number"
console.log(scientific);      // Outputs: 5000

Basic Arithmetic Operations:
JavaScript supports all basic arithmetic operations: 
addition, subtraction, multiplication, division, and 
modulus (remainder).

Example:

let a = 10;
let b = 3;


console.log(a + b);  // Addition: 13

console.log(a - b);  // Subtraction: 7

console.log(a * b);  // Multiplication: 30

console.log(a / b);  // Division: 3.3333...

console.log(a % b);  // Modulus: 1

Increment and Decrement:
JavaScript also provides increment (++) and decrement 
(--) operators:

let count = 5;

count++;  // Increment
console.log(count);  // Outputs: 6

count--;  // Decrement
console.log(count);  // Outputs: 5

The Math Object:
JavaScript provides a built-in Math object that contains 
properties and methods for mathematical constants and 
functions.

Mathematical Constants:
The Math object includes several mathematical constants:

console.log(Math.PI);    // pi (≈3.14159)

console.log(Math.E);     // Euler's number (≈2.71828)

console.log(Math.SQRT2); // Square root of 2 (≈1.41421)


Common Math Methods:

Math.abs(): 
Returns the absolute value of a number.

console.log(Math.abs(-5));  // Outputs: 5

Math.round(), Math.ceil(), Math.floor(): Different ways 
of rounding numbers.

console.log(Math.round(4.7));  // Outputs: 5

console.log(Math.ceil(4.2));   // Outputs: 5

console.log(Math.floor(4.8));  // Outputs: 4

Math.max() and Math.min(): 
Return the largest and smallest values respectively.

console.log(Math.max(1, 3, 2));  // Outputs: 3

console.log(Math.min(1, 3, 2));  // Outputs: 1

Math.pow(): 
Returns the base to the exponent power.

console.log(Math.pow(2, 3));  // Outputs: 8 (2^3)

Math.sqrt(): 
Returns the square root of a number.

console.log(Math.sqrt(16));  // Outputs: 4

Math.random(): 
Returns a pseudo-random number between 0 and 1.

console.log(Math.random());  // Outputs: a random 
number between 0 and 1

Handling Precision and Rounding Errors:
As mentioned earlier, JavaScript's use of floating-point 
numbers can lead to precision errors in certain 
calculations. 

This is particularly noticeable with decimal arithmetic.

Example of precision error:
console.log(0.1 + 0.2);  // Outputs: 0.30000000000000004

To handle these errors, you can use techniques like rounding 
to a fixed number of decimal places:

let result = (0.1 + 0.2).toFixed(2);
console.log(result);  // Outputs: "0.30" i.e a string

console.log(typeof result) // string

Note that toFixed() returns a string, so you might need 
to convert it back to a number:

let numericResult = Number((0.1 + 0.2).toFixed(2));
console.log(numericResult);  // Outputs: 0.3

Working with BigInt:
For cases where you need to work with integers larger 
than 2^53 - 1, JavaScript provides the BigInt type 
(introduced in ES2020).

let bigNumber = 1234567890123456789012345678901234567890n;
console.log(typeof bigNumber);  // Outputs: "bigint"

Note that you can't mix BigInt and regular numbers in 
operations:

let result = 1n + 2;  // Throws a TypeError

You need to convert one type to the other:

let result = 1n + BigInt(2);
console.log(result);  // Outputs: 3n

Understanding how JavaScript handles numbers and math 
operations is crucial for accurate calculations in your 
programs. Always be aware of potential precision issues 
when working with floating-point arithmetic, and use 
appropriate techniques to handle them when necessary.


5. Dates and Times:

Introduction to the Date Object
JavaScript provides a built-in Date object to work with 
dates and times. The Date object allows you to create, 
manipulate, and format dates, as well as perform time-based 
calculations.

Creating Date Objects:
There are several ways to create a Date object:

Current date and time:
let now = new Date();

console.log(now);  // Outputs the current date and time

Specific date and time:
let specificDate = new Date(2023, 0, 15, 10, 30, 0);

console.log(specificDate);  // Outputs: Sun Jan 15 2023 10:30:00

Note: Months are zero-indexed (0-11), where 0 represents January.

From a date string:
let dateFromString = new Date("2023-01-15T10:30:00");

console.log(dateFromString);  // Outputs: Sun Jan 15 2023 10:30:00

From timestamp (milliseconds since January 1, 1970):
let dateFromTimestamp = new Date(1673778600000);

console.log(dateFromTimestamp);  
// Outputs: Sun Jan 15 2023 10:30:00

Getting Date Components
The Date object provides several methods to extract individual 
components of a date:

let date = new Date(2023, 0, 15, 10, 30, 0);

console.log(date.getFullYear());     // 2023

console.log(date.getMonth());        // 0 (January)

console.log(date.getDate());         // 15

console.log(date.getDay());          // 0 (Sunday)

console.log(date.getHours());        // 10

console.log(date.getMinutes());      // 30

console.log(date.getSeconds());      // 0

console.log(date.getMilliseconds()); // 0

console.log(date.getTime()) // 1673775000000

Note: 
getDay(): returns the day of the week (0-6), where 0 represents 
Sunday.

getDate(): returns the day of the month (0 - 31);

Setting Date Components:

Similarly, you can set individual components of a date:

let date = new Date(2023, 0, 15);

date.setFullYear(2024);

date.setMonth(6);  // July

date.setDate(20);  // 20

date.setHours(15); // 15

date.setMinutes(45); // 45

date.setSeconds(30); // 30

console.log(date); // Outputs: Sat Jul 20 2024 15:45:30

Formatting Dates:
JavaScript doesn't have built-in extensive date formatting 
options, but you can create custom formats using the available 
methods:

function formatDate(date) {
    let day = date.getDate().toString().padStart(2, '0');

    let month = (date.getMonth() + 1).toString().padStart(2, '0');
    
    let year = date.getFullYear();

    return `${day}/${month}/${year}`;
}

let date = new Date(2023, 0, 15);
console.log(formatDate(date));  // Outputs: 15/01/2023

For more advanced formatting, you can use the Intl.DateTimeFormat 
object:

let date = new Date(2023, 0, 15);

let formatter = new Intl.DateTimeFormat('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
});

console.log(formatter.format(date));  // Outputs: January 15, 2023

Performing Date Calculations:
You can perform various calculations with dates:

Adding or subtracting days:
let date = new Date(2023, 0, 15);

date.setDate(date.getDate() + 7); i.e 15 + 7 = 22
console.log(date);  // Outputs: Sun Jan 22 2023

Calculating the difference between dates:

let date1 = new Date(2023, 0, 1);
let date2 = new Date(2023, 11, 31);

let difference = date2 - date1;
console.log(difference) // 31449600000

let days = Math.floor(difference / (1000 * 60 * 60 * 24));

console.log(`There are ${days} days between the dates`);  
// Outputs: There are 364 days between the dates

31449600000/86,400,000 = 364

Working with Timestamps:
Timestamps represent the number of milliseconds since 
January 1, 1970 (Unix Epoch). They're useful for storing 
dates in a numeric format and for date calculations.

let now = new Date();
let timestamp = now.getTime();

console.log(timestamp);  // Outputs: current timestamp
e.g: 1762799858818

Note:.getTime() helps get d timestamps

Creating a date from a timestamp:
let dateFromTimestamp = new Date(timestamp);

console.log(dateFromTimestamp);  // Outputs: current date 
and time

Handling Time Zones:
By default, JavaScript works with dates in the local time 
zone of the system it's running on. However, you can work 
with UTC (Coordinated Universal Time) using specific 
methods:

let date = new Date();

console.log(date.getUTCHours());  // Hours in UTC
console.log(date.getHours());     // Hours in local time zone

// Getting the time zone offset in minutes
console.log(date.getTimezoneOffset());

Best Practices and Common Pitfalls:

Always consider time zones: 
Be aware that dates may be interpreted differently depending 
on the user's time zone.

Use UTC for storing dates: 
When storing dates, especially for future events, consider 
using UTC to avoid time zone issues.

Be cautious with date parsing: 
Parsing date strings can be unpredictable across different 
browsers. It's often safer to manually parse date strings 
or use a library.

Consider using a date library: 
For complex date operations or consistent cross-browser 
behavior, consider using a library like Moment.js or 
date-fns.

Working with dates and times is a common task in many 
applications. Understanding these concepts will help 
you handle various date-related operations effectively 
in your JavaScript programs.


C. JS in the Browser
====================

1. The Document Object Model (DOM):

Understanding the DOM Tree:
The Document Object Model (DOM) is a crucial concept in web 
development, serving as the bridge between web pages and 
programming languages like JavaScript. It's not just a simple 
concept, but a complex, hierarchical structure that represents 
every element on a web page.

What is the DOM?:
The DOM is an object-oriented representation of a web document. 

It's not part of JavaScript itself, but rather a Web API that 
browsers implement. 

The DOM represents an HTML or XML document as a tree-like 
structure where each node is an object representing a part 
of the document.

Key points to understand:
The DOM is language-agnostic, meaning it can be used with various 
programming languages, not just JavaScript.

It provides a structured representation of the document, allowing 
programs to read and manipulate the document's content, structure, 
and styles.

The DOM is live, meaning that when it's modified, the page's 
display updates to reflect the changes.

DOM Tree Structure:
Let's break down a simple HTML document into its DOM 
representation:

<!DOCTYPE html>
<html>
    <head>
        <title>My Web Page</title>
    </head>

    <body>
        <h1>Welcome</h1>

        <p>This is a paragraph.</p>
    </body>
</html>

The corresponding DOM tree would look like this:

Document
|
└── DOCTYPE: html
|
└── HTML
    ├── HEAD
    │   └── TITLE
    │       └── Text: "My Web Page"
    └── BODY
        ├── H1
        │   └── Text: "Welcome"
        └── P
            └── Text: "This is a paragraph."

Each box in this tree is a node in the DOM. There are 
several types of nodes:

Document node: 
The root of the tree, representing the entire document.

Element nodes: 
Represent HTML elements.

Attribute nodes: 
Represent attributes of elements.

Text nodes: 
Represent text within elements.

Comment nodes: 
Represent HTML comments.

Understanding this structure is crucial because it forms 
the basis of how we select and manipulate elements using 
JavaScript.

Selecting DOM Elements:
Before we can manipulate elements, we need to select them. 

JavaScript provides several methods to do this, each with 
its own use cases.

Selecting Elements by ID:
The getElementById() method is the fastest way to select 
a single element:

const headingElement = document.getElementById('main-heading');

This selects the element with id="main-heading". Remember, 
IDs should be unique within a document.

Selecting Elements by Class Name:
To select elements by their class, use getElementsByClassName():

const paragraphs = document.getElementsByClassName('content-paragraph');

This returns a live HTMLCollection of ALL elements with the 
class 'content-paragraph'.

Selecting Elements by Tag Name:
getElementsByTagName() selects all elements of a specified tag:

const allDivs = document.getElementsByTagName('div');

Using CSS Selectors;
The most flexible methods are querySelector() and querySelectorAll(). 
These allow you to use any valid CSS selector:

// Select the first .button element inside #menu
const firstButton = document.querySelector('#menu .button');

// Select all .item elements
const allItems = document.querySelectorAll('.item');

querySelector() returns the first matching element, while 
querySelectorAll() returns a NodeList of ALL matching 
elements.

Manipulating DOM Elements:
Once we've selected elements, we can manipulate them in 
various ways.

Changing Text Content:
To change the text of an element:

const heading = document.querySelector('h1');

heading.textContent = 'New Heading Text';

textContent is preferred over innerText as it's faster 
and doesn't trigger a reflow.

Changing HTML Content:
To change the HTML inside an element:

const paragraph = document.querySelector('p');

paragraph.innerHTML = 
    'This is <strong>bold</strong> text.';

Be cautious with innerHTML as it can pose security 
risks if used with user-input data.

Changing Attributes:
Attributes can be get, set, or removed:

const link = document.querySelector('a');

// Get attribute
console.log(link.getAttribute('href'));

// Set attribute
link.setAttribute('href', 'https://example.com');

// Remove attribute
link.removeAttribute('target');

Changing Styles:
Inline styles can be manipulated via the style property:

const div = document.querySelector('div');

div.style.backgroundColor = 'blue';
div.style.padding = '10px';

For more complex style changes, it's often better to add 
or remove classes:

div.classList.add('highlight');

div.classList.remove('hidden');

div.classList.toggle('active');

Creating and Removing DOM Elements:

Creating Elements:
To create a new element:

const newParagraph = document.createElement('p');

newParagraph.textContent = 'This is a new paragraph.';

Adding Elements to the DOM:
To add the new element to the document:

document.body.appendChild(newParagraph);

You can also insert at a specific position:
const referenceElement = document.querySelector('#existing-element');

document.body.insertBefore(newParagraph, referenceElement);

Removing Elements:
To remove an element:

const elementToRemove = document.querySelector('#remove-me');

elementToRemove.parentNode.removeChild(elementToRemove);

Or using the more modern remove() method:

elementToRemove.remove();

Practical Exercise: 
Dynamic To-Do List

Let's create a more complex to-do list application that 
demonstrates various DOM manipulation techniques:

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic To-Do List</title>

    <style>
        .completed { 
            text-decoration: line-through; 

            color: gray; 
        }
    </style>
</head>

<body>
    <h1>My To-Do List</h1>

    <input type="text" id="todoInput" placeholder="Enter a new task">
    <button id="addButton">Add Task</button>

    <ul id="todoList"></ul>

    <script>
        const todoInput = document.getElementById('todoInput');
        const addButton = document.getElementById('addButton');
        const todoList = document.getElementById('todoList');

        addButton.addEventListener('click', addTask);

        function addTask() {
            if (todoInput.value.trim() === '') return;

            const li = document.createElement('li');
            li.textContent = todoInput.value;

            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';

            deleteButton.addEventListener('click', () => li.remove());

            const completeButton = document.createElement('button');
            completeButton.textContent = 'Complete';

            completeButton.addEventListener('click', () => 
                li.classList.toggle('completed')
            );

            li.appendChild(deleteButton);
            li.appendChild(completeButton);

            todoList.appendChild(li);

            todoInput.value = '';
        }
    </script>
</body>
</html>


This example demonstrates:
Creating elements (createElement)

Adding elements to the DOM (appendChild)

Handling events (addEventListener)

Manipulating classes (classList.toggle)

Removing elements (remove)

Advanced DOM Concepts:

DOM Traversal:
The DOM allows for easy traversal between nodes:

const parent = element.parentNode;

const nextSibling = element.nextSibling;

const previousSibling = element.previousSibling;

const children = element.childNodes;

Performance Considerations:
DOM manipulation can be expensive. For better performance:

Minimize DOM access and updates

Use document fragments for batch insertions

Consider using requestAnimationFrame for visual updates

Event Delegation:
Instead of attaching events to individual elements, you can 
attach a single event listener to a parent element:

todoList.addEventListener('click', function(e) {
    if (e.target.tagName === 'BUTTON') {
        if (e.target.textContent === 'Delete') {
            e.target.parentNode.remove();
        } else if (e.target.textContent === 'Complete') {
            e.target.parentNode.classList.toggle('completed');
        }
    }
});

This technique is more efficient and works for dynamically 
added elements.

Conclusion
The DOM is a powerful interface that allows JavaScript to 
interact with web pages. Understanding how to navigate, 
manipulate, and create DOM elements is crucial for creating 
dynamic and interactive web applications. As you progress, 
you'll discover more advanced techniques and best practices 
for working with the DOM efficiently.


2. Events in JavaScript:
Events are a fundamental part of JavaScript programming, 
especially when it comes to creating interactive web 
applications. They allow us to respond to user actions 
and system occurrences, making our web pages dynamic and 
responsive.

Understanding Event-Driven Programming:
In event-driven programming, the flow of the program is 
determined by events such as user actions, sensor outputs, 
or messages from other programs. In the context of web 
development, these events are typically user interactions 
like clicks, key presses, or mouse movements.

JavaScript uses an event-driven programming model. Instead 
of executing code in a strictly linear fashion, JavaScript 
waits for events to occur and then executes designated 
functions (called event handlers or event listeners) in 
response to those events.

Common Types of Events:
JavaScript can handle a wide variety of events. Here are 
some of the most common:

Mouse events: 
click, dblclick, mousedown, mouseup, mousemove, mouseover, 
mouseout

Keyboard events: 
keydown, keyup, keypress

Form events: 
submit, change, focus, blur

Window events: 
load, resize, scroll, unload

Adding Event Listeners:
To respond to an event, we need to attach an event listener 
to the relevant DOM element. 

The addEventListener method is the modern way to handle 
events in JavaScript. Here's its basic syntax:

element
    .addEventListener(eventType, eventHandler, useCapture);

eventType: 
A string that specifies the event type (e.g., 'click', 'keydown')

eventHandler: 
The function to be executed when the event occurs

useCapture: 
An optional boolean parameter for advanced event handling 
(default is false)

Let's look at a simple example:

const button = document.querySelector('#myButton');

function handleClick() {
    console.log('Button clicked!');
}

button.addEventListener('click', handleClick);

In this example, we're attaching a 'click' event listener 
to a button. When the button is clicked, it will log 
"Button clicked!" to the console.

The Event Object:
When an event occurs, JavaScript automatically passes an 
event object to the event handler function. 

function handleClick(event) {}

This object contains useful information about the event. 
Let's modify our previous example to use the event object:

function handleClick(event) {
    console.log('Button clicked!');

    console.log('Event type:', event.type);
    console.log('Target element:', event.target);
}

button.addEventListener('click', handleClick);

The event object provides properties like:

type: 
The type of event (e.g., 'click', 'keydown')

target: 
The element that triggered the event

clientX/clientY: 
The mouse position for mouse events

key: 
The key pressed for keyboard events

Removing Event Listeners:
Sometimes, you might want to stop listening for an event. 
You can do this with the removeEventListener method:

button
    .removeEventListener('click', handleClick);

Note that to remove a listener, you need to specify the 
same function that was originally added. This is why it's 
often better to use named functions instead of anonymous 
functions when adding event listeners.

Event Bubbling and Capturing:

When an event happens on an element, it first runs the 
handlers on it, then on its parent, then all the way up 
on other ancestors. 

This process is called "bubbling", because events "bubble" 
from the inner element up through parents like a bubble in 
water.

Here's an example to demonstrate bubbling:

<div id="outer">
    <div id="inner">
        <button id="button">Click me</button>
    </div>
</div>

<script>
    document
        .getElementById('outer')
        .addEventListener('click', 
            () => console.log('Outer div clicked')
        );

    document
        .getElementById('inner')
        .addEventListener('click', 
            () => console.log('Inner div clicked')
        );

    document
        .getElementById('button')
        .addEventListener('click', 
            () => console.log('Button clicked')
        );
</script>

If you click the button, you'll see three messages in 
the console:

"Button clicked"

"Inner div clicked"

"Outer div clicked"

This is bubbling in action. The event starts at the button, 
then bubbles up to its parent elements.

The opposite of bubbling is capturing. It's rarely used, but 
for completeness, you should know that events actually travel 
in three phases:

Capturing phase – the event goes down to the element

Target phase – the event reaches the target element

Bubbling phase – the event bubbles up from the element

You can use the third parameter of addEventListener to catch 
events on the capturing phase:

element.addEventListener('click', handler, true);

Preventing Default Behavior:
Some events have default behaviors. For example, when you 
click on a link, it will navigate to the URL. Sometimes 
you want to prevent this default behavior. You can do this 
with the preventDefault() method of the event object:

document.querySelector('a').addEventListener('click', function(event) {
    event.preventDefault();

    console.log('Link clicked, but page navigation prevented');
});

Practical Exercise: 
Interactive Image Gallery

Let's create a simple image gallery to practice working 
with events:

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Interactive Image Gallery</title>

        <style>
            .thumbnail { width: 100px; height: 100px; object-fit: cover; margin: 5px; cursor: pointer; }
            #featured { width: 500px; height: 500px; object-fit: cover; }
        </style>
    </head>

    <body>
        <div id="gallery">
            <img src="https://picsum.photos/id/1/500/500" alt="Featured Image" id="featured">
        
            <div id="thumbnails">
                <img src="https://picsum.photos/id/1/100/100" alt="Thumbnail 1" class="thumbnail">
                <img src="https://picsum.photos/id/2/100/100" alt="Thumbnail 2" class="thumbnail">
                <img src="https://picsum.photos/id/3/100/100" alt="Thumbnail 3" class="thumbnail">
                <img src="https://picsum.photos/id/4/100/100" alt="Thumbnail 4" class="thumbnail">
            </div>
        </div>

        <script>
            const featured = document.getElementById('featured');
            const thumbnails = document.getElementById('thumbnails');

            thumbnails.addEventListener('click', function(event) {
                if (event.target.classList.contains('thumbnail')) {
                    featured.src = event.target.src.replace('100/100', '500/500');
                }
            });

            featured.addEventListener('mouseenter', function() {
                this.style.opacity = '0.7';
            });

            featured.addEventListener('mouseleave', function() {
                this.style.opacity = '1';
            });
        </script>
    </body>
</html>

This example demonstrates:
Event delegation (clicking on thumbnails)

Mouse events (mouseenter and mouseleave)

Manipulating styles based on events

Preventing the need for multiple event listeners by using 
event delegation

Events are a powerful feature of JavaScript that allow you 
to create truly interactive web applications. As you 
continue to develop your skills, you'll find countless ways 
to use events to enhance user experiences and create dynamic, 
responsive interfaces.


3. Forms and Input Handling
Forms are a crucial part of web applications, enabling users 
to input and submit data. JavaScript provides various methods 
and techniques to handle forms, validate user input, and 
enhance the overall user experience.

Capturing and Validating Form Data:
When users interact with a form, the data they input must be 
captured, processed, and often validated before submission. 

JavaScript plays a key role in these tasks, ensuring that 
the data is correct and complete before being sent to the 
server.

Accessing Form Elements:
JavaScript allows you to access form elements using various 
methods:

document.forms: 
Accesses all forms on a page.

document.getElementById(): 
Retrieves a specific form element by its ID.

form.elements[]: 
Accesses elements within a specific form by name or index.

For example:

let form = document.forms['myForm'];
let nameInput = form.elements['name'];
let emailInput = document.getElementById('email');

Handling Form Submissions:
To handle form submissions, you can attach an event listener 
to the form's submit event. This allows you to intercept the 
submission, validate the data, and either allow the 
submission to proceed or prevent it.

Example:

form.addEventListener('submit', function(event) {
    // Prevents the default form submission behavior
    event.preventDefault(); 

    let name = nameInput.value.trim();
    let email = emailInput.value.trim();

    if (validateForm(name, email)) {
        // Proceed with form submission (e.g., via AJAX)
    } else {
        alert('Please fill out the form correctly.');
    }
});

Validating Input Fields:
JavaScript provides several ways to validate input fields 
before submission:

Required Fields: 
Ensure that fields are not left empty.

Pattern Matching: 
Validate data formats (e.g., email, phone numbers) using 
regular expressions, Regex.

Length Checks: 
Ensure the input meets minimum or maximum length requirements.

Example:

function validateForm(name, email) {
    if (name === '' || email === '') {
        return false;
    }

    // Basic email validation
    let emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

    if (!emailPattern.test(email)) {
        return false;
    }

    return true;
}

Handling User Input with JavaScript:
Handling user input effectively is essential for creating 
responsive and user-friendly forms. JavaScript can respond 
to user actions, such as typing, selecting options, and 
more, to provide immediate feedback or manipulate data.

Real-Time Input Validation:
You can validate user input in real-time as they type 
or select options. This approach improves user experience 
by providing immediate feedback and guiding users to 
correct any errors.

Example:

emailInput.addEventListener('input', function() {
    let isValid = emailPattern.test(this.value);
    
    this.style.borderColor = isValid ? 'green' : 'red';
});

Handling Different Input Types
JavaScript allows you to handle various input types, such 
as text, checkboxes, radio buttons, and more. Each input 
type has specific properties and methods that can be used 
to capture and process data.

Example:

let gender = document.querySelector('input[name="gender"]:checked').value;
let interests = Array.from(document.querySelectorAll('input[name="interests"]:checked')).map(el => el.value);

console.log('Gender:', gender);
console.log('Interests:', interests.join(', '));

Preventing Default Form Behaviors
Sometimes, you may want to prevent the default behavior 
of forms, such as submitting or navigating away from the 
current page. JavaScript allows you to control these 
behaviors to provide a more customized user experience.

Preventing Form Submission
You can prevent form submission using 
event.preventDefault() within a submit event handler. 
This is useful for forms that require client-side 
validation or need to submit data via AJAX.

Example:

form.addEventListener('submit', function(event) {
    event.preventDefault(); // Prevents the default submission

    // Custom form handling logic
    submitFormData();
});

Preventing Default Input Actions
For other input elements, such as links or buttons, you 
can also prevent default actions like navigation or form 
resets.

Example:

document.querySelector('a').addEventListener('click', function(event) {
    event.preventDefault(); // Prevents link navigation

    alert('Link was clicked but default navigation was prevented.');
});

Practical Exercise: Simple Registration Form
Let’s apply what we’ve learned by creating a simple 
registration form with validation and JavaScript-based 
handling.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Registration Form</title>

    <style>
        .error { color: red; }
        .valid { color: green; }
    </style>
</head>

<body>
    <form id="registrationForm">
        <label for="name">Name:</label>
        <input type="text" id="name" name="name">
        <span id="nameError" class="error"></span>
        <br><br>

        <label for="email">Email:</label>
        <input type="email" id="email" name="email">
        <span id="emailError" class="error"></span>
        <br><br>

        <label for="password">Password:</label>
        <input type="password" id="password" name="password">
        <span id="passwordError" class="error"></span>
        <br><br>

        <button type="submit">Register</button>
    </form>

    <script>
        const form = document.getElementById('registrationForm');
        const nameInput = document.getElementById('name');
        const emailInput = document.getElementById('email');
        const passwordInput = document.getElementById('password');

        const nameError = document.getElementById('nameError');
        const emailError = document.getElementById('emailError');
        const passwordError = document.getElementById('passwordError');

        form.addEventListener('submit', function(event) {
            event.preventDefault(); // Prevent form submission

            // Clear previous errors
            nameError.textContent = '';
            emailError.textContent = '';
            passwordError.textContent = '';

            // Validate fields
            let isValid = true;

            if (nameInput.value.trim() === '') {
                nameError.textContent = 'Name is required.';
                isValid = false;
            }

            if (emailInput.value.trim() === '' || !emailInput.value.includes('@')) {
                emailError.textContent = 'Valid email is required.';
                isValid = false;
            }

            if (passwordInput.value.trim().length < 6) {
                passwordError.textContent = 'Password must be at least 6 characters long.';
                isValid = false;
            }

            if (isValid) {
                alert('Registration successful!');
                form.reset(); // Reset form fields
            }
        });
    </script>
</body>
</html>

Summary
Handling forms and input in JavaScript is a vital skill 
for any web developer. By effectively capturing, 
validating, and managing user input, you can create more 
interactive, user-friendly, and secure web applications. 
As you practice, you'll discover even more ways to harness 
the power of JavaScript to improve your forms and user 
interaction


4. Working with Browser Storage
In modern web applications, storing data locally in the 
user's browser can significantly enhance the user 
experience by enabling persistent data storage across 
sessions. JavaScript provides various methods for 
client-side storage, including localStorage, sessionStorage, 
and cookies.

Introduction to Local Storage and Session Storage
Local storage and session storage are part of the Web 
Storage API, allowing developers to store key-value pairs 
directly in the browser.

Local Storage
localStorage is used to store data with no expiration time. 
The data persists even after the browser is closed and 
reopened. This is useful for storing data that should be 
available across sessions, such as user preferences or 
settings.

Example:

// Setting an item in local storage
localStorage.setItem('username', 'JohnDoe');

// Retrieving an item from local storage
let username = localStorage.getItem('username');
console.log(username); // Output: JohnDoe

// Removing an item from local storage
localStorage.removeItem('username');

// Clearing all items in local storage
localStorage.clear();

Session Storage
sessionStorage is similar to localStorage, but it only 
persists data for the duration of the page session. 
Once the browser tab is closed, the data is lost. This 
is ideal for storing temporary data like form inputs 
during a session.

Example:

// Setting an item in session storage
sessionStorage.setItem('sessionID', 'abc123');

// Retrieving an item from session storage
let sessionID = sessionStorage.getItem('sessionID');
console.log(sessionID); // Output: abc123

// Removing an item from session storage
sessionStorage.removeItem('sessionID');

// Clearing all items in session storage
sessionStorage.clear();

Storing and Retrieving Data in the Browser
Storing and retrieving data in localStorage and 
sessionStorage is straightforward. The data is stored 
as strings, so if you're storing complex data types 
like arrays or objects, you'll need to convert them 
to strings using JSON.stringify() and convert them 
back using JSON.parse().

Example:

// Storing an object in localStorage
let user = { name: 'John', age: 30 };
localStorage.setItem('user', JSON.stringify(user));

// Retrieving and parsing the object from localStorage
let storedUser = JSON.parse(localStorage.getItem('user'));
console.log(storedUser.name); // Output: John

Similarly, you can store arrays, nested objects, or any 
other serializable data structures.

Understanding Cookies and Their Usage in JavaScript
Cookies are another way to store data in the browser. 
They have been around longer than the Web Storage API 
and are often used for tracking, authentication, and 
storing small amounts of data.

Setting and Retrieving Cookies
Cookies are managed using the document.cookie property. 
Unlike localStorage and sessionStorage, cookies are 
automatically sent to the server with every HTTP request.

Example:

// Setting a cookie
document.cookie = "username=JohnDoe; expires=Fri, 
31 Dec 2024 12:00:00 UTC; path=/";

// Retrieving cookies
let cookies = document.cookie;
console.log(cookies); // Output: username=JohnDoe

// Function to get a specific cookie by name
function getCookie(name) {
    let matches = document.cookie.match(new RegExp(
        "(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"
    ));

    return matches ? decodeURIComponent(matches[1]) : undefined;
}

console.log(getCookie('username')); // Output: JohnDoe

Cookie Attributes
expires: 
Sets an expiration date for the cookie.

path: 
Defines the path where the cookie is accessible.

domain: 
Specifies the domain that can access the cookie.

secure: 
Ensures the cookie is sent only over HTTPS.

httpOnly: 
Restricts access to the cookie via JavaScript, enhancing 
security.

Example:

// Setting a secure cookie that can only be sent over HTTPS
document.cookie = "token=abc123; secure; httpOnly; path=/";

Practical Exercise: User Preferences with Local Storage

Let’s create a simple example where user preferences 
(like theme selection) are stored in localStorage.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>User Preferences</title>

    <style>
        body.light-theme { background-color: white; color: black; }
        body.dark-theme { background-color: black; color: white; }
    </style>
</head>

<body>
    <h1>Choose Your Theme</h1>
    <button id="lightTheme">Light Theme</button>
    <button id="darkTheme">Dark Theme</button>

    <script>
        const lightThemeButton = document.getElementById('lightTheme');
        const darkThemeButton = document.getElementById('darkTheme');

        // Apply stored theme on page load
        const savedTheme = localStorage.getItem('theme');

        if (savedTheme) {
            document.body.className = savedTheme;
        }

        // Event listeners for theme buttons
        lightThemeButton.addEventListener('click', () => {
            document.body.className = 'light-theme';
            localStorage.setItem('theme', 'light-theme');
        });

        darkThemeButton.addEventListener('click', () => {
            document.body.className = 'dark-theme';
            localStorage.setItem('theme', 'dark-theme');
        });
    </script>
</body>
</html>

In this example:
The user can select a light or dark theme.

The selected theme is stored in localStorage so that it 
persists across sessions.

When the page is reloaded, the stored theme is automatically 
applied.

Summary
Browser storage is a powerful tool for creating more dynamic 
and persistent user experiences. Whether you need to store 
data temporarily during a session or across multiple sessions, 
localStorage, sessionStorage, and cookies offer versatile 
solutions. Understanding how to effectively use these tools 
will allow you to build more sophisticated and user-friendly 
web applications.


5. Asynchronous JavaScript

Asynchronous programming is a fundamental concept in JavaScript 
that allows you to perform tasks in the background without 
blocking the main thread. This is especially useful when 
handling tasks like fetching data from a server, reading files, 
or performing complex calculations. JavaScript provides several 
ways to work with asynchronous operations, including callbacks, 
promises, and the async/await syntax.

Introduction to Callbacks
A callback is a function that is passed as an argument to another 
function and is executed after some operation has been completed. 
Callbacks are one of the earliest methods of handling asynchronous 
operations in JavaScript.

Basic Callback Example
Here’s a simple example to illustrate how callbacks work:

function fetchData(callback) {
    setTimeout(() => {
        let data = { id: 1, name: 'John Doe' };

        callback(data);
    }, 2000); // Simulating a 2-second delay
}

function displayData(data) {
    console.log('Data received:', data);
}

fetchData(displayData);

In this example:
fetchData simulates an asynchronous operation (e.g., fetching 
data from a server) using setTimeout.

The displayData function is passed as a callback and is called 
when the data is ready.

Callback Hell
While callbacks are simple and effective, they can lead to 
what’s known as "callback hell" when dealing with multiple 
asynchronous operations, resulting in deeply nested and 
hard-to-maintain code.

Example:

fetchData1((data1) => {
    fetchData2(data1, (data2) => {

        fetchData3(data2, (data3) => {

            console.log('Final data:', data3);

        });

    });
});

Introduction to Promises
Promises are a more powerful way to handle asynchronous operations 
in JavaScript. A promise represents the eventual completion (or 
failure) of an asynchronous operation and its resulting value.

Creating a Promise
A promise can be created using the Promise constructor, which 
takes a function (called the executor) that receives two arguments: 
resolve and reject.

Example:

let myPromise = new Promise((resolve, reject) => {
    let success = true;

    if (success) {
        resolve('Operation successful!');
    } else {
        reject('Operation failed.');
    }
});

myPromise
    .then((message) => {
        console.log(message); // Output: Operation successful!
    })
    .catch((error) => {
        console.log(error);
    });

In this example:
If the operation is successful, resolve is called, and the 
promise is fulfilled.

If the operation fails, reject is called, and the promise is 
rejected.

then() is used to handle a fulfilled promise, and catch() handles a 
rejected promise.

Chaining Promises
One of the main advantages of promises is that they can be chained, 
making it easier to handle sequential asynchronous operations.

Example:

fetchData1()
    .then((data1) => fetchData2(data1))

    .then((data2) => fetchData3(data2))

    .then((data3) => {
        console.log('Final data:', data3);
    })
    .catch((error) => {
        console.error('Error:', error);
    });

Using async/await
The async/await syntax is a more recent addition to JavaScript 
that simplifies working with promises. It allows you to write 
asynchronous code that looks and behaves more like synchronous 
code, making it easier to read and maintain.

Creating an Async Function
An async function is a function declared with the async keyword. 
Inside an async function, you can use the await keyword to pause 
the execution of the function until a promise is resolved.

Example:

async function fetchData() {
    let response = await fetch('https://api.example.com/data');

    let data = await response.json();

    console.log('Data:', data);
}

fetchData();

In this example:
fetchData is an async function that fetches data from an API.

await is used to wait for the fetch promise to resolve before continuing.

The code is easier to understand compared to using promise chaining.

Error Handling with try/catch
You can handle errors in an async function using try/catch blocks.

Example:

async function fetchData() {
    try {
        let response = await fetch('https://api.example.com/data');

        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        let data = await response.json();

        console.log('Data:', data);
    } catch (error) {
        console.error('Error fetching data:', error);
    }
}

fetchData();

In this example:
try/catch is used to handle errors that may occur during the 
asynchronous operation.

Making HTTP Requests with the Fetch API
The Fetch API is a modern way to make HTTP requests in JavaScript. 
It returns a promise that resolves to the Response object 
representing the response to the request.

Basic Fetch Example
Here’s how you can use the Fetch API to make a GET request:

fetch('https://api.example.com/data')
    .then((response) => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        return response.json();
    })
    .then((data) => {
        console.log('Data:', data);
    })
    .catch((error) => {
        console.error('Error:', error);
    });

Using Fetch with async/await
The Fetch API works seamlessly with async/await syntax:

async function fetchData() {
    try {
        let response = await fetch('https://api.example.com/data');

        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        let data = await response.json();

        console.log('Data:', data);
    } catch (error) {
        console.error('Error:', error);
    }
}

fetchData();

Handling Asynchronous Operations and Errors
Effective error handling is crucial when working with asynchronous 
operations to ensure your application behaves correctly under 
different conditions.

Handling Multiple Promises with Promise.all
Promise.all allows you to execute multiple promises in parallel 
and wait for all of them to resolve.

Example:

let promise1 = fetch('https://api.example.com/data1');
let promise2 = fetch('https://api.example.com/data2');

Promise.all([promise1, promise2])
    .then((responses) => {
        return Promise.all(responses.map((response) => response.json()));
    })
    .then((data) => {
        console.log('Data from both APIs:', data);
    })
    .catch((error) => {
        console.error('Error fetching data:', error);
    });

Handling Promises Independently with Promise.race
Promise.race returns a promise that resolves or rejects as soon 
as one of the promises in the array resolves or rejects.

Example:

let promise1 = new Promise((resolve) => setTimeout(resolve, 100, 'First'));
let promise2 = new Promise((resolve) => setTimeout(resolve, 200, 'Second'));

Promise.race([promise1, promise2])
    .then((value) => {
        console.log('Race won by:', value);
    });

Practical Exercise: 
Fetching and Displaying Data from an API

Let’s create a simple example that fetches data from an API 
and displays it on a webpage.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Data Fetch</title>
</head>

<body>
    <h1>User Data</h1>
    <ul id="userList"></ul>

    <script>
        async function fetchUserData() {
            try {
                let response = await fetch('https://jsonplaceholder.typicode.com/users');

                if (!response.ok) {
                    throw new Error('Failed to fetch data');
                }

                let users = await response.json();

                displayUsers(users);
            } catch (error) {
                console.error('Error:', error);
            }
        }

        function displayUsers(users) {
            const userList = document.getElementById('userList');

            users.forEach(user => {
                let listItem = document.createElement('li');

                listItem.textContent = `${user.name} (${user.email})`;

                userList.appendChild(listItem);
            });
        }

        fetchUserData();
    </script>
</body>
</html>

In this example:
The fetchUserData function asynchronously fetches user data from 
an API.

The fetched data is displayed as a list on the webpage.

Summary
Asynchronous programming in JavaScript is essential for creating 
smooth and responsive web applications. Understanding callbacks, 
promises, and async/await is crucial for effectively managing 
asynchronous operations and handling errors. With these tools, 
you can write cleaner, more efficient, and easier-to-maintain 
code while providing a better user experience.


D. Advanced JS Concepts
=======================

1. Object Oriented JavaScript

Object-oriented programming (OOP) is a paradigm that uses 
objects to design and organize software. In JavaScript, 
OOP is supported through prototypes and classes, allowing 
you to create and manage complex data structures and 
behaviors. Understanding OOP concepts in JavaScript enables 
you to write more modular, reusable, and maintainable code.

Introduction to Prototypes and Inheritance
JavaScript is a prototype-based language, which means that 
objects can inherit properties and methods from other 
objects. This inheritance mechanism is a key part of JavaScript's 
OOP capabilities.

What is a Prototype?
In JavaScript, every object has a prototype, which is another 
object that it inherits properties and methods from. This
prototype chain allows objects to share functionality.

Example:

let animal = {
    eats: true,
    sleep() {
        console.log("The animal is sleeping.");
    }
};

let dog = {
    barks: true
};

// Set animal as the prototype of dog
dog.__proto__ = animal;

console.log(dog.eats); 
// Output: true (inherited from animal)

dog.sleep();
// Output: The animal is sleeping. (inherited from animal)

In this example:
dog inherits properties and methods from animal through 
the prototype chain.

Prototype Chain
The prototype chain is a series of links between objects. 
When you access a property or method on an object, JavaScript 
will first look for that property on the object itself. If it 
doesn't find it, it will continue to search up the prototype 
chain until it either finds the property or reaches the end 
of the chain (usually Object.prototype).

Creating and Using Constructor Functions
Before ES6 introduced classes, constructor functions were 
the primary way to create objects in an OOP manner.

Defining a Constructor Function
A constructor function is a special type of function that 
is used to create instances of objects. By convention, 
constructor functions start with an uppercase letter.

Example:

function Person(name, age) {
    this.name = name;

    this.age = age;
}

Person.prototype.greet = function() {
    console.log(`Hello, my name is ${this.name}.`);
};

let john = new Person('John', 30);
let jane = new Person('Jane', 25);

john.greet(); // Output: Hello, my name is John.
jane.greet(); // Output: Hello, my name is Jane.

In this example:
Person is a constructor function.

The new keyword is used to create instances of Person.

Methods can be added to the Person.prototype so that 
all instances share the same method.

Inheritance with Constructor Functions
You can implement inheritance with constructor functions by 
setting the prototype of the child constructor to an 
instance of the parent constructor.

Example:

function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function() {
    console.log(`${this.name} makes a sound.`);
};

function Dog(name, breed) {
    Animal.call(this, name); // Call the parent constructor
    this.breed = breed;
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.speak = function() {
    console.log(`${this.name} barks.`);
};

let rex = new Dog('Rex', 'Golden Retriever');
rex.speak(); // Output: Rex barks.

In this example:
Dog inherits from Animal.

Dog.prototype is set to an object created from Animal.prototype.

The speak method is overridden in the Dog constructor.

Introduction to Classes in ES6
ith the introduction of ES6, JavaScript added a new syntax 
for creating objects and handling inheritance: classes. While 
classes are mostly syntactic sugar over JavaScript’s existing 
prototype-based inheritance, they provide a cleaner and more 
intuitive syntax for working with objects and inheritance.

Defining a Class
A class is defined using the class keyword. Inside a class, 
you can define a constructor method (for initializing new 
instances) and other methods.

Example:

class Person {
    constructor(name, age) {
        this.name = name;

        this.age = age;
    }

    greet() {
        console.log(`Hello, my name is ${this.name}.`);
    }
}

let john = new Person('John', 30);
john.greet(); // Output: Hello, my name is John.


Inheritance with Classes
Classes make it easier to set up inheritance using the extends 
keyword.

Example:

class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        console.log(`${this.name} makes a sound.`);
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // Call the parent constructor

        this.breed = breed;
    }

    speak() {
        console.log(`${this.name} barks.`);
    }
}

let rex = new Dog('Rex', 'Golden Retriever');
rex.speak(); // Output: Rex barks.

In this example:
Dog extends Animal, inheriting its properties and methods.

The super keyword is used to call the parent constructor.

Static Methods and Properties
Static methods and properties belong to the class itself, not 
to instances of the class.

Example:

class MathHelper {
    static square(x) {
        return x * x;
    }
}

console.log(MathHelper.square(4)); // Output: 16

In this example:
square is a static method, and it is called directly on the 
MathHelper class.

Understanding the this Keyword
The this keyword in JavaScript refers to the object that is 
executing the current function. Its value can vary depending 
on the context in which the function is called.

this in Constructor Functions
In a constructor function, this refers to the instance being 
created.

Example:

function Car(model) {
    this.model = model;
}

let myCar = new Car('Toyota');
console.log(myCar.model); // Output: Toyota

this in Methods
In methods, this refers to the object that owns the method.

Example:

let car = {
    model: 'Honda',

    start() {
        console.log(`Starting ${this.model}`);
    }
};

car.start(); // Output: Starting Honda

this in Event Handlers
In event handlers, this refers to the element that received 
the event.

Example:

<button id="myButton">Click me</button>

<script>
    let button = document.getElementById('myButton');

    button.addEventListener('click', function() {
        console.log(this.id); // Output: myButton
    });
</script>

Binding this
In some cases, you might need to explicitly bind this to a 
specific value, especially when passing methods as callbacks.

Example:

let car = {
    model: 'Ford',

    start() {
        console.log(`Starting ${this.model}`);
    }
};

let startCar = car.start.bind(car);
startCar(); // Output: Starting Ford


Practical Exercise: 
Building a Simple Shopping Cart with Classes

Let’s create a simple shopping cart system using classes.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shopping Cart</title>
</head>

<body>
    <h1>Shopping Cart</h1>

    <ul id="cartItems"></ul>

    <button id="addItem">Add Item</button>

    <script>
        class Item {
            constructor(name, price) {
                this.name = name;

                this.price = price;
            }

            display() {
                return `${this.name}: $${this.price}`;
            }
        }

        class ShoppingCart {
            constructor() {
                this.items = [];
            }

            addItem(item) {
                this.items.push(item);

                this.displayCart();
            }

            displayCart() {
                const cartItems = document.getElementById('cartItems');

                cartItems.innerHTML = '';

                this.items.forEach(item => {
                    let listItem = document.createElement('li');

                    listItem.textContent = item.display();

                    cartItems.appendChild(listItem);
                });
            }
        }

        const cart = new ShoppingCart();

        document.getElementById('addItem').addEventListener('click', () => {
            let newItem = new Item('Apple', 0.99);

            cart.addItem(newItem);
        });
    </script>
</body>
</html>


In this example:
The Item class represents a product in the cart.

The ShoppingCart class manages the list of items and displays 
them.

The cart updates dynamically when you click the "Add Item" 
button.

Summary
Object-oriented programming in JavaScript allows you to 
organize your code more effectively by creating reusable 
objects and structures. By understanding prototypes, 
classes, and the this keyword, you can build more complex 
applications that are modular, scalable, and easier to 
maintain. As you continue to work with JavaScript, mastering 
these OOP concepts will be crucial in writing efficient 
and high-quality code.


2. JavaScript Modules

Modules are a powerful feature in JavaScript that allows 
you to organize your code into separate, reusable pieces. 
With the introduction of ES6, JavaScript natively supports 
modules, enabling developers to break down their code 
into smaller, more manageable files, each with its own 
scope.

Understanding Module Patterns
Before the introduction of ES6 modules, developers used 
various patterns to create modular code in JavaScript. 
These include the Module Pattern, Immediately Invoked 
Function Expressions (IIFE), and CommonJS (used in 
Node.js). While these patterns are still in use, ES6 
modules have become the standard for modern JavaScript 
development.

Module Pattern
The Module Pattern involves creating an object or 
function that encapsulates private variables and 
functions, exposing only what’s necessary to the 
outside world.

Example:

const myModule = (function() {
    let privateVariable = 'I am private';

    function privateMethod() {
        console.log(privateVariable);
    }

    return {
        publicMethod: function() {
            privateMethod();
        }
    };
})();

myModule.publicMethod(); // Output: I am private

In this example:
privateVariable and privateMethod are encapsulated 
within the module and cannot be accessed directly 
from outside.

publicMethod is exposed and can be called from outside, 
giving controlled access to the module’s functionality.

CommonJS (Node.js)
In Node.js, modules are created using the CommonJS 
pattern, where module.exports is used to export 
variables, functions, or objects from a module, and 
require() is used to import them.

Example:

// math.js
function add(a, b) {
    return a + b;
}

module.exports = {
    add
};

// main.js
const math = require('./math');
console.log(math.add(2, 3)); // Output: 5

In this example:
The add function is exported from math.js using 
module.exports.

It is then imported in main.js using require().

ES6 Modules
ES6 introduced a standardized module system that is 
now widely used in both front-end and back-end JavaScript 
development. ES6 modules use the import and export keywords 
to handle module dependencies.

Exporting Modules
You can export variables, functions, or objects from a 
module using the export keyword.

Named Exports
Named exports allow you to export multiple items from a 
module, which can then be imported individually by name.

Example:

// math.js
export function add(a, b) {
    return a + b;
}

export const PI = 3.14159;

In this example:
Both the add function and the PI constant are exported 
using named exports.

Default Exports
A module can also have a default export, which is useful 
when a module primarily exports a single item.

Example:

// math.js
export default function subtract(a, b) {
    return a - b;
}

In this example:
The subtract function is exported as the default export 
of the module.

Importing Modules
Modules can be imported into other files using the 
import keyword.

Importing Named Exports
To import named exports, you must use the exact names of 
the exported items.

Example:

// main.js
import { add, PI } from './math';

console.log(add(2, 3)); // Output: 5
console.log(PI); // Output: 3.14159

In this example:
The add function and PI constant are imported by their 
names from the math.js module.

Importing Default Exports
Default exports can be imported using any name you choose.

Example:

// main.js
import subtract from './math';

console.log(subtract(5, 3)); // Output: 2

In this example:
The subtract function is imported as the default export 
from math.js.

Importing All Exports
You can import all the named exports from a module as 
an object.

Example:

// main.js
import * as math from './math';

console.log(math.add(2, 3)); // Output: 5
console.log(math.PI); // Output: 3.14159

In this example:
All exports from math.js are imported into the math 
object.

Organizing Code with Modules
Using modules, you can organize your code into logical 
pieces, each responsible for a specific part of your 
application. This modularity improves code readability, 
maintainability, and reusability.

Example: Modularizing a Simple Application
Suppose you are building a simple application that 
calculates areas and circumferences of circles. You 
can split the logic into multiple modules.

circle.js
export function calculateArea(radius) {
    return Math.PI * radius * radius;
}

export function calculateCircumference(radius) {
    return 2 * Math.PI * radius;
}

main.js
import { calculateArea, calculateCircumference } from './circle';

let radius = 5;
console.log(`Area: ${calculateArea(radius)}`); 
// Output: Area: 78.53981633974483

console.log(`Circumference: ${calculateCircumference(radius)}`); 
// Output: Circumference: 31.41592653589793

In this example:
The circle.js module contains the logic for calculating areas 
and circumferences.

The main.js file imports the necessary functions and uses them 
to perform calculations.

Dynamic Imports
ES6 modules also support dynamic imports, which allow you 
to load modules on demand. This is particularly useful for 
large applications where you want to load modules only when 
they are needed.

Example:

function loadModule() {
    import('./math.js')
        .then((module) => {
            console.log(module.add(2, 3)); // Output: 5
        })
        .catch((error) => {
            console.error('Error loading module:', error);
        });
}

loadModule();

In this example:
The math.js module is loaded dynamically when the loadModule 
function is called.

Practical Exercise: 
Creating a Simple To-Do List App with Modules
Let’s create a simple to-do list application using ES6 modules 
to organize the code.

task.js
export class Task {
    constructor(description) {
        this.description = description;

        this.completed = false;
    }

    toggleComplete() {
        this.completed = !this.completed;
    }
}


taskManager.js
import { Task } from './task.js';

export class TaskManager {
    constructor() {
        this.tasks = [];
    }

    addTask(description) {
        const task = new Task(description);

        this.tasks.push(task);
    }

    getTasks() {
        return this.tasks;
    }
}

main.js
import { TaskManager } from './taskManager.js';

const taskManager = new TaskManager();

document.getElementById('addTask').addEventListener('click', () => {
    const taskDescription = document.getElementById('taskDescription').value;

    taskManager.addTask(taskDescription);

    displayTasks();
});

function displayTasks() {
    const tasks = taskManager.getTasks();

    const taskList = document.getElementById('taskList');

    taskList.innerHTML = '';

    tasks.forEach((task, index) => {
        const listItem = document.createElement('li');

        listItem.textContent = `${task.description} - ${task.completed ? 'Completed' : 'Not Completed'}`;

        listItem.addEventListener('click', () => {
            task.toggleComplete();

            displayTasks();
        });

        taskList.appendChild(listItem);
    });
}

index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>To-Do List App</title>
</head>

<body>
    <h1>To-Do List</h1>
    <input type="text" id="taskDescription" placeholder="Enter task description">

    <button id="addTask">Add Task</button>

    <ul id="taskList"></ul>

    <script type="module" src="./main.js"></script>
</body>
</html>

In this example:
The application is modularized into Task, TaskManager, and 
main.js.

The Task class represents individual tasks, while TaskManager 
manages the list of tasks.

The main file (main.js) handles the interaction with the HTML 
and displays the tasks.

Summary
JavaScript modules provide a powerful way to structure and 
organize your code into manageable, reusable pieces. By 
understanding and utilizing ES6 modules, you can write 
cleaner, more modular, and maintainable code. Modules also 
promote better separation of concerns, making your code 
easier to debug, test, and extend. As you work on more 
complex projects, mastering modules will be essential 
for effective JavaScript development.


3. Error Handling

Error handling is a critical aspect of writing robust and 
reliable code. In JavaScript, errors can occur for various 
reasons, such as invalid input, network failures, or logical 
mistakes. Proper error handling allows you to anticipate 
potential problems and respond to them gracefully, ensuring 
that your application continues to run smoothly or fails 
gracefully when necessary.

Understanding Different Types of Errors
JavaScript errors can generally be classified into three main 
types: syntax errors, runtime errors, and logical errors.

Syntax Errors
Syntax errors occur when the JavaScript engine encounters 
code that doesn’t follow the correct syntax rules of the 
language. These errors are often detected during the 
initial parsing of the code and will prevent the code 
from executing.

Example:

let a = 5;
let b =; // SyntaxError: Unexpected token ;

In this example:
The missing value after = causes a syntax error, which 
will stop the script from running.

Runtime Errors
Runtime errors occur while the script is executing. 
These errors happen when the JavaScript engine encounters 
something unexpected, such as calling a function that 
doesn't exist or trying to access an undefined variable.

Example:

function divide(a, b) {
    return a / b;
}

console.log(divide(10, 0)); 
// Infinity (but no error in JavaScript)

console.log(nonExistentVariable); 
// ReferenceError: nonExistentVariable is not defined

In this example:
The division by zero does not cause an error in JavaScript, 
but accessing an undefined variable does.

Logical Errors
Logical errors are mistakes in the logic of the code that 
produce incorrect results. These errors do not produce 
error messages but can lead to unexpected behavior.

Example:

function calculateTotal(price, tax) {
    return price + tax;
}

console.log(calculateTotal(100, 0.05));
// Output: 100.05 (incorrect if tax was meant to be a 
percentage)

In this example:
The logical error is in how the tax is applied. The 
function should multiply the price by the tax rate, 
not add it directly.

Using try, catch, and finally for Error Handling
JavaScript provides a try...catch...finally statement 
for handling errors gracefully. This allows you to 
attempt to execute code and catch any errors that occur 
during execution.

The try Block
The try block contains the code that you want to execute. 
If an error occurs in this block, control is passed to 
the catch block.

Example:

try {
    let result = divide(10, 0);
    console.log(result);
} catch (error) {
    console.log('An error occurred:', error.message);
}

In this example:
If an error occurs within the try block, the catch block 
is executed.

The catch Block
The catch block is executed if an error occurs in the 
try block. It receives an error object that provides 
details about the error.

Example:

try {
    let result = nonExistentFunction();
} catch (error) {
    // Output: Caught an error: nonExistentFunction is not defined
    console.log('Caught an error:', error.message); 
}

In this example:
The catch block catches the error and logs an error 
message.

The finally Block
The finally block is optional and contains code that will 
run regardless of whether an error occurred or not. This 
is useful for cleaning up resources or performing other 
necessary actions.

Example:

try {
    let result = divide(10, 2);
    console.log(result);
} catch (error) {
    console.log('An error occurred:', error.message);
} finally {
    console.log('This will run regardless of the outcome.');
}

In this example:
The finally block is executed whether or not an error occurs 
in the try block.

Throwing Errors Manually
Sometimes, you might want to throw an error manually to 
handle specific cases or enforce certain conditions. You 
can do this using the throw statement.

Throwing an Error
You can throw an error using the throw statement, and 
you can create custom error messages.

Example:

function divide(a, b) {
    if (b === 0) {
        throw new Error('Division by zero is not allowed.');
    }
    return a / b;
}

try {
    console.log(divide(10, 0));
} catch (error) {
    // Output: Caught an error: Division by zero is not allowed.
    console.log('Caught an error:', error.message); 
}

In this example:
The throw statement is used to manually throw an error 
if a division by zero is attempted.

Custom Error Objects
You can also create custom error objects by extending 
the built-in Error class.

Example:

class CustomError extends Error {
    constructor(message) {
        super(message);
        this.name = 'CustomError';
    }
}

try {
    throw new CustomError('This is a custom error.');
} catch (error) {
    console.log(error.name); 
    // Output: CustomError
    
    console.log(error.message); 
    // Output: This is a custom error.
}

In this example:
A custom error class CustomError is created, which can 
be used to throw specific errors.

Best Practices for Error Handling
Proper error handling is essential for building resilient 
applications. Here are some best practices:

1. Handle Errors Gracefully
Ensure that your application can recover from errors 
without crashing. Provide meaningful error messages 
and fallback options where appropriate.

Example:

try {
    let data = JSON.parse('invalid JSON');
} catch (error) {
    console.log('Error parsing JSON:', error.message);
    data = {}; // Fallback to an empty object
}

2. Log Errors for Debugging
Log errors to help with debugging and monitoring. This 
is especially important in production environments.

Example:

try {
    let result = someFunction();
} catch (error) {
    console.error('An unexpected error occurred:', error); 
    // Logs the error to the console
}

3. Avoid Silent Failures
Do not suppress errors or ignore them, as this can lead 
to unpredictable behavior and make debugging difficult.

Example:

try {
    let result = someFunction();
} catch (error) {
    console.error('Error:', error.message); // Log the error
    // Handle the error appropriately
}

4. Use finally for Cleanup
Use the finally block to clean up resources or perform 
actions that should happen regardless of whether an 
error occurred.

Example:

function readFile(filename) {
    let file;
    try {
        file = openFile(filename);
        // Process the file
    } catch (error) {
        console.error('Error:', error.message);
    } finally {
        if (file) {
            file.close(); // Clean up the file resource
        }
    }
}

Practical Exercise: 
Building a Simple Form Validator
Let’s create a simple form validation script that checks 
if required fields are filled out and throws errors if 
they are not.

index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Form Validator</title>
</head>

<body>
    <h1>Registration Form</h1>

    <form id="registrationForm">
        <label for="username">Username:</label>
        <input type="text" id="username" name="username"><br><br>

        <label for="email">Email:</label>
        <input type="text" id="email" name="email"><br><br>

        <button type="submit">Register</button>
    </form>

    <script src="validator.js"></script>
</body>
</html>

validator.js

document.getElementById('registrationForm').addEventListener('submit', function(event) {
    event.preventDefault(); // Prevent form submission

    try {
        validateForm();

        alert('Form submitted successfully!');
    } catch (error) {
        alert('Form submission failed: ' + error.message);
    }
});

function validateForm() {
    let username = document.getElementById('username').value.trim();
    let email = document.getElementById('email').value.trim();

    if (!username) {
        throw new Error('Username is required.');
    }

    if (!email) {
        throw new Error('Email is required.');
    }

    if (!validateEmail(email)) {
        throw new Error('Invalid email format.');
    }
}

function validateEmail(email) {
    const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

    return emailPattern.test(email);
}

In this example:
The form validation checks if the username and email 
fields are filled out and whether the email has a valid 
format.

If any validation fails, an error is thrown, and the 
form submission is halted.

Summary
Effective error handling is a cornerstone of robust 
JavaScript programming. By understanding different 
types of errors and utilizing try...catch...finally 
blocks, you can manage unexpected situations gracefully. 
Throwing errors manually allows for custom error 
handling, while best practices ensure your code 
remains resilient, maintainable, and easier to debug. 
As you continue developing more complex applications, 
mastering error handling will be essential for ensuring 
a smooth and


4. Functional Programming in JavaScript

Functional programming (FP) is a programming paradigm 
that treats computation as the evaluation of mathematical 
functions and avoids changing state or mutable data. In 
JavaScript, functional programming techniques are widely 
used to write clean, concise, and predictable code.

Introduction to Higher-Order Functions
A higher-order function is a function that takes another 
function as an argument, returns a function, or both. 
Higher-order functions are a cornerstone of functional 
programming, enabling you to build more abstract and 
reusable code.

Example: Higher-Order Functions

function greet(name) {
    return `Hello, ${name}!`;
}

function greetSomeone(greetFunction, name) {
    return greetFunction(name);
}

console.log(greetSomeone(greet, 'Alice')); 
// Output: Hello, Alice!

In this example:
greetSomeone is a higher-order function because it 
takes greet (a function) as an argument.

Using map, filter, and reduce
JavaScript provides several built-in higher-order 
functions that are commonly used in functional 
programming: map, filter, and reduce. These functions 
operate on arrays and allow you to perform operations 
like transforming, filtering, and accumulating values.

map: Transforming Arrays
The map function creates a new array by applying a 
function to each element of an existing array.

Example:

const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(num => num * 2);
console.log(doubled); // Output: [2, 4, 6, 8, 10]

In this example:
map applies the function num => num * 2 to each element 
of numbers, producing a new array doubled.

filter: Filtering Arrays
The filter function creates a new array containing only 
the elements that pass a specified test.

Example:

const numbers = [1, 2, 3, 4, 5];
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // Output: [2, 4]

In this example:
filter applies the function num => num % 2 === 0 to each 
element of numbers and returns a new array with only the 
even numbers.

reduce: Accumulating Values
The reduce function reduces an array to a single value 
by applying a function to each element, accumulating 
the result.

Example:

const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((total, num) => total + num, 0);
console.log(sum); // Output: 15

In this example:
reduce adds each element of numbers to the total, starting 
with an initial value of 0.

Closures and the Concept of Immutability
Closures and immutability are key concepts in functional 
programming, helping to ensure that your functions are 
pure and predictable.

Closures
A closure is a function that remembers the environment in 
which it was created, even after that environment has gone 
out of scope.

Example:

function makeCounter() {
    let count = 0;

    return function() {
        count++;
        return count;
    };
}

const counter = makeCounter();
console.log(counter()); // Output: 1
console.log(counter()); // Output: 2

In this example:
The inner function returned by makeCounter is a closure 
because it remembers the count variable even after 
makeCounter has finished executing.

Immutability
Immutability refers to the concept of not changing the 
original data. Instead, new data is created when 
modifications are needed. This reduces side effects and 
makes your code more predictable.

Example:

const person = { name: 'John', age: 30 };

const updatedPerson = { ...person, age: 31 };

console.log(person); // Output: { name: 'John', age: 30 }
console.log(updatedPerson); // Output: { name: 'John', age: 31 }

In this example:
The person object is not modified directly. Instead, a 
new object updatedPerson is created with the updated age.

Pure Functions
A pure function is a function that:
Returns the same output for the same input.

Has no side effects (it doesn’t modify any external state).

Pure functions are a central concept in functional 
programming because they are predictable and easy to test.

Example:

function add(a, b) {
    return a + b;
}

console.log(add(2, 3)); // Output: 5
console.log(add(2, 3)); // Output: 5

In this example:
add is a pure function because it always returns the 
same result for the same inputs and doesn’t modify 
any external state.

Function Composition
Function composition is the process of combining two or 
more functions to produce a new function. In functional 
programming, this is a common way to build complex 
operations from simpler ones.

Example:

const add = x => x + 1;
const multiply = x => x * 2;

const addThenMultiply = x => multiply(add(x));

console.log(addThenMultiply(5)); // Output: 12

In this example:
addThenMultiply composes the add and multiply functions, 
first adding 1 to x and then multiplying the result by 2.

Practical Exercise: 
Functional Programming with a Shopping Cart

Let’s create a simple shopping cart application using 
functional programming techniques.

cart.js

const addItem = (cart, item) => [...cart, item];

const removeItem = (cart, itemName) => cart.filter(item => item.name !== itemName);

const calculateTotal = cart => cart.reduce((total, item) => total + item.price, 0);

export { addItem, removeItem, calculateTotal };

main.js

import { addItem, removeItem, calculateTotal } from './cart.js';

let cart = [];

cart = addItem(cart, { name: 'Apple', price: 0.99 });
cart = addItem(cart, { name: 'Banana', price: 1.29 });

console.log('Cart:', cart); 
// Output: Cart: [{ name: 'Apple', price: 0.99 }, { name: 'Banana', price: 1.29 }]

cart = removeItem(cart, 'Apple');

console.log('Cart after removal:', cart); 
// Output: Cart after removal: [{ name: 'Banana', price: 1.29 }]

const total = calculateTotal(cart);
console.log('Total:', total); // Output: Total: 1.29

In this example:
The shopping cart is managed using pure functions and 
immutable data structures.

Each function (e.g., addItem, removeItem, calculateTotal) 
operates on the cart and returns a new cart or value, 
without modifying the original cart.

Summary
Functional programming in JavaScript emphasizes the use 
of pure functions, immutability, and higher-order functions 
to create clean, predictable, and reusable code. By mastering 
concepts like map, filter, reduce, closures, and function 
composition, you can write more efficient and maintainable 
JavaScript code. As you incorporate functional programming 
techniques into your projects, you'll find that your code 
becomes more modular, easier to test, and less prone to 
bugs.


5. Working with APIs

APIs (Application Programming Interfaces) allow different 
software applications to communicate with each other. In 
web development, APIs are commonly used to fetch data from 
external services or to interact with third-party platforms. 
Understanding how to work with APIs is essential for 
creating dynamic and data-driven applications in JavaScript.

Fetching Data from External APIs
JavaScript provides several ways to fetch data from external 
APIs, with the Fetch API being the most modern and widely 
used method. The Fetch API returns a promise that resolves 
to the Response object representing the response to the 
request.

Basic Fetch Example
Here’s how you can use the Fetch API to make a GET request:

fetch('https://jsonplaceholder.typicode.com/posts')
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        return response.json();
    })
    .then(data => {
        console.log(data);
    })
    .catch(error => {
        console.error('There was a problem with the fetch operation:', error);
    });

In this example:
fetch is used to send a GET request to the API endpoint.

The response.json() method parses the JSON data from the 
response.

The resulting data is logged to the console, and any errors 
are caught and logged.

Parsing and Using JSON Data
APIs often return data in JSON (JavaScript Object Notation) 
format, which is easy to work with in JavaScript. Once the 
JSON data is fetched, you can parse it and use it within 
your application.

Example: Displaying API Data

fetch('https://jsonplaceholder.typicode.com/users')
    .then(response => response.json())
    .then(users => {
        users.forEach(user => {
            console.log(`${user.name} (${user.email})`);
        });
    })
    .catch(error => console.error('Error:', error));

In this example:
The JSON data containing user information is fetched and 
parsed.

The data is then iterated over using forEach, and the user 
names and emails are logged to the console.

Handling API Errors and Status Codes
Proper error handling is essential when working with APIs 
to ensure your application behaves correctly in all 
scenarios. The Fetch API allows you to handle different 
types of errors, such as network errors or issues related 
to the API itself (e.g., 404 Not Found or 500 Internal 
Server Error).

Example: Handling Different Status Codes

fetch('https://jsonplaceholder.typicode.com/posts/1')
    .then(response => {
        if (response.ok) {
            return response.json();
        } else if (response.status === 404) {
            throw new Error('Resource not found (404)');
        } else {
            throw new Error('Something went wrong');
        }
    })
    .then(data => console.log(data))
    .catch(error => console.error('Error:', error));

In this example:
The response status is checked to determine the appropriate 
action.

If the response is not OK (e.g., 404 Not Found), an error 
is thrown with a specific message.

The error is caught and logged.

Making POST Requests
In addition to fetching data with GET requests, you can 
also send data to an API using POST requests. This is 
commonly used when submitting forms or sending new data 
to a server.

Example: Sending Data with POST

const postData = {
    title: 'foo',
    body: 'bar',
    userId: 1
};

fetch('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST',

    headers: {
        'Content-Type': 'application/json'
    },
    
    body: JSON.stringify(postData)
})
.then(response => response.json())

.then(data => console.log(data))

.catch(error => console.error('Error:', error));

In this example:
A new post is created by sending a POST request to the API.

The headers object specifies the content type as JSON.

The body contains the JSON stringified data to be sent.

The API response is then logged to the console.

Using Async/Await with APIs
The async/await syntax provides a more readable and 
synchronous-like way to handle asynchronous operations, 
including working with APIs.

Example: Fetching Data with Async/Await

async function fetchData() {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/todos');

        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        const data = await response.json();

        console.log(data);
    } catch (error) {
        console.error('Fetch error:', error);
    }
}

fetchData();

In this example:
The fetchData function is declared as async.

The await keyword is used to wait for the fetch and JSON 
parsing to complete.

Errors are handled with a try/catch block.

Practical Exercise: 
Creating a Weather Application

Let’s create a simple weather application that fetches 
weather data from an API and displays it on the page.

index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather App</title>
</head>

<body>
    <h1>Weather App</h1>

    <input type="text" id="city" placeholder="Enter city name">
    
    <button id="getWeather">Get Weather</button>
    
    <div id="weather"></div>

    <script src="weather.js"></script>
</body>
</html>

weather.js

document.getElementById('getWeather').addEventListener('click', async () => {
    const city = document.getElementById('city').value;

    const apiKey = 'YOUR_API_KEY';
    
    const url = `https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=metric`;

    try {
        const response = await fetch(url);

        if (!response.ok) {
            throw new Error('City not found');
        }

        const data = await response.json();
        
        displayWeather(data);
    } catch (error) {
        document.getElementById('weather').textContent = error.message;
    }
});

function displayWeather(data) {
    const weatherDiv = document.getElementById('weather');

    weatherDiv.textContent = 
        `The weather in ${data.name} is ${data.weather[0].description} 
        with a temperature of ${data.main.temp}°C.`;
}

In this example:
The weather data is fetched from the OpenWeatherMap API based on 
the city name entered by the user.

The API key (apiKey) needs to be replaced with your own from 
OpenWeatherMap.

The weather data is then displayed on the page, showing the 
description and temperature.

Summary
Working with APIs is a fundamental skill for modern web development. 
By mastering techniques like fetching data, handling errors, and 
making POST requests, you can integrate external data and services 
into your JavaScript applications. Using async/await further enhances 
the readability and maintainability of your code. As you continue 
to work with APIs, you'll find that they open up a world of 
possibilities for creating dynamic, data-driven applications.


E. JS in Practice
=================

1. DOM Manipulation Projects
DOM (Document Object Model) manipulation is a crucial skill 
for web developers, allowing you to dynamically change the 
content, structure, and style of a webpage using JavaScript. 
This lesson focuses on building interactive UI components 
and creating dynamic content with JavaScript through hands-on 
projects.

Project 1: 
Building a Simple To-Do List Application
A to-do list application is a great starting point for 
practicing DOM manipulation. This project will involve 
adding, displaying, and removing tasks dynamically.

Step 1: Setting Up the HTML
Start by creating a simple HTML structure for the to-do list.

index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>To-Do List</title>
</head>

<body>
    <h1>To-Do List</h1>

    <input type="text" id="newTask" placeholder="Enter a new task">

    <button id="addTask">Add Task</button>

    <ul id="taskList"></ul>

    <script src="todo.js"></script>
</body>
</html>

In this structure:
An input field and button allow users to add new tasks.

An unordered list (<ul>) will display the tasks.

Step 2: Adding Tasks Dynamically
Next, implement the JavaScript to handle adding tasks to 
the list.

todo.js

document.getElementById('addTask').addEventListener('click', () => {
    const taskInput = document.getElementById('newTask');

    const taskText = taskInput.value.trim();

    if (taskText !== '') {
        addTask(taskText);

        taskInput.value = ''; // Clear the input field
    }
});

function addTask(task) {
    const taskList = document.getElementById('taskList');

    const listItem = document.createElement('li');
    listItem.textContent = task;

    // Add a delete button to each task
    const deleteButton = document.createElement('button');
    deleteButton.textContent = 'Delete';

    deleteButton.addEventListener('click', () => {
        taskList.removeChild(listItem);
    });

    listItem.appendChild(deleteButton);
    taskList.appendChild(listItem);
}

In this code:
The addTask function creates a new list item (<li>) for 
each task and appends it to the task list.

A delete button is added to each task, allowing users to 
remove tasks from the list.

Step 3: Enhancing the UI
You can further enhance the to-do list by adding features 
like task completion.

Enhancing todo.js

function addTask(task) {
    const taskList = document.getElementById('taskList');

    const listItem = document.createElement('li');
    listItem.textContent = task;

    // Add a delete button to each task
    const deleteButton = document.createElement('button');
    deleteButton.textContent = 'Delete';

    deleteButton.addEventListener('click', () => {
        taskList.removeChild(listItem);
    });

    // Add a checkbox for task completion
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';

    checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
            listItem.style.textDecoration = 'line-through';
        } else {
            listItem.style.textDecoration = 'none';
        }
    });

    listItem.prepend(checkbox);
    listItem.appendChild(deleteButton);
    taskList.appendChild(listItem);
}

In this enhancement:
A checkbox is added to each task, allowing users to mark 
tasks as completed by striking through the text.

Project 2: 
Creating an Image Gallery with Modal View

This project involves building an interactive image gallery
where users can click on thumbnails to view larger versions 
of the images in a modal window.

Step 1: Setting Up the HTML
Create the basic structure for the image gallery.

index.html

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Image Gallery</title>

        <style>
            .thumbnail { 
                width: 100px; 
                height: 100px; 
                object-fit: cover; 
                cursor: pointer; 
            }

            #modal { 
                display: none; 
                position: fixed; 
                top: 0; 
                left: 0; 
                width: 100%; 
                height: 100%; 
                background: rgba(0, 0, 0, 0.8); 
                justify-content: center; 
                align-items: center; 
            }
            
            #modal img { 
                max-width: 90%; 
                max-height: 90%; 
            }
        </style>
    </head>

    <body>
        <div id="gallery">
            <img src="https://picsum.photos/id/1/100/100" alt="Thumbnail 1" class="thumbnail">

            <img src="https://picsum.photos/id/2/100/100" alt="Thumbnail 2" class="thumbnail">

            <img src="https://picsum.photos/id/3/100/100" alt="Thumbnail 3" class="thumbnail">

            <img src="https://picsum.photos/id/4/100/100" alt="Thumbnail 4" class="thumbnail">
        </div>

        <div id="modal">
            <img src="" alt="Large View" id="modalImage">
        </div>

        <script src="gallery.js"></script>
    </body>
</html>

In this structure:
The gallery contains several thumbnails, each displayed 
as an image.

The modal (<div id="modal">) is initially hidden and will 
    display the large version of the clicked image.

Step 2: Implementing the Modal Logic
Add JavaScript to handle the modal view when a thumbnail 
is clicked.

gallery.js

const thumbnails = document.querySelectorAll('.thumbnail');
const modal = document.getElementById('modal');
const modalImage = document.getElementById('modalImage');

thumbnails.forEach(thumbnail => {
    thumbnail.addEventListener('click', () => {
        modalImage.src = thumbnail.src.replace('/100/100', '/500/500');

        modal.style.display = 'flex';
    });
});

modal.addEventListener('click', () => {
    modal.style.display = 'none';
});

In this code:
When a thumbnail is clicked, the modal displays the larger 
version of the image by replacing the thumbnail’s dimensions 
in the URL.

Clicking anywhere on the modal will close it by setting 
display: none.

Project 3: Building a Dynamic Content Slider
A content slider (or carousel) is a common feature on many 
websites, allowing users to cycle through different pieces 
of content. This project will create a simple slider with 
next and previous buttons.

Step 1: Setting Up the HTML
Create the structure for the content slider.

index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Content Slider</title>

    <style>
        #slider { 
            position: relative; 
            width: 300px; 
            height: 200px; 
            overflow: hidden; 
        }

        .slide { 
            display: none; 
            position: absolute; 
            width: 100%; 
            height: 100%; 
        }

        .slide img { 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
        }

        #prev, #next { 
            position: absolute; 
            top: 50%; 
            transform: translateY(-50%); 
            background: rgba(0, 0, 0, 0.5); 
            color: white; 
            border: none; 
            cursor: pointer; 
            padding: 10px; 
        }
        
        #prev { 
            left: 10px; 
        }
        
        #next { 
            right: 10px; 
        }
    </style>
</head>

<body>
    <div id="slider">
        <div class="slide"><img src="https://picsum.photos/id/101/300/200" alt="Slide 1"></div>

        <div class="slide"><img src="https://picsum.photos/id/102/300/200" alt="Slide 2"></div>

        <div class="slide"><img src="https://picsum.photos/id/103/300/200" alt="Slide 3"></div>

        <div class="slide"><img src="https://picsum.photos/id/104/300/200" alt="Slide 4"></div>


        <button id="prev">Prev</button>
        <button id="next">Next</button>
    </div>

    <script src="slider.js"></script>
</body>
</html>

In this structure:
The slider contains several slides, each with an image.

The slides are stacked on top of each other, with only 
one slide visible at a time.

Next and Previous buttons allow users to navigate 
through the slides.

Step 2: Implementing the Slider Logic
Add JavaScript to handle slide transitions when the next 
or previous button is clicked.

slider.js

let currentSlide = 0;
const slides = document.querySelectorAll('.slide');
const totalSlides = slides.length;

document.getElementById('next').addEventListener('click', () => {
    changeSlide(1);
});

document.getElementById

('prev').addEventListener('click', () => {
    changeSlide(-1);
});

function changeSlide(direction) {
    slides[currentSlide].style.display = 'none';

    currentSlide = (currentSlide + direction + totalSlides) % totalSlides;
    
    slides[currentSlide].style.display = 'block';
}

// Initialize the slider by showing the first slide
slides[currentSlide].style.display = 'block';

In this code:
The changeSlide function handles moving to the next 
or previous slide by adjusting the currentSlide index.

The modulo operator (%) ensures the slide index wraps 
around when reaching the first or last slide.

Summary
DOM manipulation is a fundamental skill in web development, 
enabling you to create dynamic and interactive user interfaces. 
By working on projects like a to-do list, image gallery, and 
content slider, you can practice and refine your ability to 
manipulate the DOM using JavaScript. These projects not only 
help you understand the basics of DOM manipulation but also 
provide a foundation for building more complex and feature-rich 
web applications.


2. Working with Events

Events are a crucial aspect of interactive web development. 
This lesson focuses on creating custom events, implementing 
drag-and-drop functionality, and building a basic game using 
event listeners.

Creating Custom Events

Understanding Custom Events
Custom events allow you to define your own events that can be 
triggered and listened to within your application. This helps 
in creating modular and reusable code.

Example: Creating and Dispatching a Custom Event

// Create a new custom event
const myEvent = new CustomEvent('myCustomEvent', {
    detail: { message: 'Hello, Custom Event!' }
});

// Add an event listener for the custom event
document.addEventListener('myCustomEvent', (e) => {
    console.log(e.detail.message); // Output: Hello, Custom Event!
});

// Dispatch the custom event
document.dispatchEvent(myEvent);

Using Custom Events with DOM Elements
Custom events can also be used with DOM elements to trigger 
and respond to events.

Example: Custom Event on a Button

<button id="myButton">Trigger Event</button>

JavaScript:

const button = document.getElementById('myButton');

// Create a custom event
const customEvent = new CustomEvent('customClick', {
    detail: { message: 'Button clicked!' }
});

// Add an event listener to handle the custom event
button.addEventListener('customClick', (e) => {
    console.log(e.detail.message); // Output: Button clicked!
});

// Trigger the custom event on button click
button.addEventListener('click', () => {
    button.dispatchEvent(customEvent);
});

Implementing Drag-and-Drop Functionality

Basics of Drag-and-Drop
Drag-and-drop functionality allows users to interact with 
elements by dragging them to new locations.

Example: Basic Drag-and-Drop

<div id="draggable" draggable="true">Drag me!</div>
<div id="dropzone">Drop here!</div>

JavaScript:

const draggable = document.getElementById('draggable');
const dropzone = document.getElementById('dropzone');

// Handle drag start event
draggable.addEventListener('dragstart', (e) => {
    e.dataTransfer.setData('text/plain', 'Dragged element');
});

// Handle drag over event
dropzone.addEventListener('dragover', (e) => {
    e.preventDefault(); // Allow drop
});

// Handle drop event
dropzone.addEventListener('drop', (e) => {
    e.preventDefault();

    const data = e.dataTransfer.getData('text');

    dropzone.textContent = `Dropped: ${data}`;
});


Enhancing Drag-and-Drop
You can add more features such as visual feedback during 
dragging and restricting drop areas.

Example: Enhanced Drag-and-Drop

<div id="draggable" draggable="true">Drag me!</div>
<div id="dropzone" class="dropzone">Drop here!</div>
<div id="target">Target Zone</div>

CSS:

.dropzone {
    width: 200px;
    height: 100px;
    border: 2px dashed #ccc;
    text-align: center;
    line-height: 100px;
    margin-top: 20px;
}

.target {
    width: 200px;
    height: 100px;
    border: 2px solid #333;
    text-align: center;
    line-height: 100px;
    margin-top: 20px;
}

JavaScript:

const draggable = document.getElementById('draggable');
const dropzone = document.getElementById('dropzone');
const target = document.getElementById('target');

draggable.addEventListener('dragstart', (e) => {
    e.dataTransfer.setData('text/plain', 'Dragged element');
});

dropzone.addEventListener('dragover', (e) => {
    e.preventDefault();

    dropzone.style.backgroundColor = '#e0e0e0';
});

dropzone.addEventListener('dragleave', () => {
    dropzone.style.backgroundColor = '';
});

dropzone.addEventListener('drop', (e) => {
    e.preventDefault();

    dropzone.style.backgroundColor = '';
    
    const data = e.dataTransfer.getData('text');
    
    dropzone.textContent = `Dropped: ${data}`;
});

Project: 
Building a Basic Game Using Event Listeners

Project Overview
In this project, you'll build a simple game where users 
can interact with elements using event listeners. For 
example, you can create a basic clicker game where users 
score points by clicking on a target.

Project Structure

HTML:

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Clicker Game</title>

        <style>
            #gameArea {
                width: 300px;
                height: 300px;
                border: 2px solid #333;
                position: relative;
                overflow: hidden;
            }

            #target {
                width: 50px;
                height: 50px;
                background-color: red;
                position: absolute;
            }
                
            #score {
                margin-top: 20px;
                font-size: 24px;
            }
        </style>
    </head>

    <body>
        <div id="gameArea">
            <div id="target"></div>
        </div>
        <div id="score">Score: 0</div>

        <script src="game.js"></script>
    </body>
</html>

JavaScript (game.js):

document.addEventListener('DOMContentLoaded', () => {
    const gameArea = document.getElementById('gameArea');
    const target = document.getElementById('target');
    const scoreElement = document.getElementById('score');
    
    let score = 0;

    function moveTarget() {
        const maxX = gameArea.clientWidth - target.offsetWidth;
        const maxY = gameArea.clientHeight - target.offsetHeight;
        
        const randomX = Math.floor(Math.random() * maxX);
        const randomY = Math.floor(Math.random() * maxY);

        target.style.left = `${randomX}px`;
        target.style.top = `${randomY}px`;
    }

    target.addEventListener('click', () => {
        score += 1;

        scoreElement.textContent = `Score: ${score}`;

        moveTarget();
    });

    moveTarget(); // Initial position
});

Explanation
HTML: 
Provides the structure for the game area, target, and 
score display.

CSS: 
Styles the game area and target.

JavaScript: 
Manages the game logic, including moving the target and 
updating the score.

Key Takeaways:
Custom Events: 
Create and use custom events for modular and reusable code.

Drag-and-Drop: 
Implement drag-and-drop functionality with visual feedback.

Event-Driven Games: 
Build interactive applications like games using event 
listeners.

Practice Exercises:
Extend the clicker game by adding multiple targets with 
varying sizes and colors.

Implement a timer that limits the duration of the game, and 
display the final score at the end.

Create a simple drawing application where users can drag 
and drop colors to draw on a canvas.


3. Advanced Asynchronous Programming

Asynchronous programming in JavaScript is crucial for handling 
tasks like API calls, file operations, and user interactions 
without blocking the main thread. In this lesson, we will delve 
deeper into advanced asynchronous programming techniques, 
including working with async/await, handling multiple 
asynchronous operations, using WebSockets for real-time 
communication, and managing complex asynchronous flows.

Implementing Complex Asynchronous Operations with async/await
The async/await syntax in JavaScript simplifies working with 
promises and makes asynchronous code easier to read and write. 
However, managing complex asynchronous operations often 
requires more advanced techniques.

Example: 
Sequential Asynchronous Operations

When you need to execute multiple asynchronous operations in 
sequence, you can use await to ensure that each operation 
completes before the next one starts.

async function fetchData() {
    try {
        const userResponse = await fetch('https://jsonplaceholder.typicode.com/users/1');
        const user = await userResponse.json();

        console.log('User:', user);

        const postsResponse = await fetch(`https://jsonplaceholder.typicode.com/posts?userId=${user.id}`);
        const posts = await postsResponse.json();

        console.log('Posts:', posts);

        const commentsResponse = await fetch(`https://jsonplaceholder.typicode.com/comments?postId=${posts[0].id}`);
        const comments = await commentsResponse.json();

        console.log('Comments on first post:', comments);
    } catch (error) {
        console.error('Error fetching data:', error);
    }
}

fetchData();

In this example:

The data is fetched in sequence: first the user, then the 
user’s posts, and finally the comments on the first post.

Each await ensures that the next operation doesn’t start 
until the previous one has completed.

Example: 
Parallel Asynchronous Operations

Sometimes, you can perform multiple asynchronous operations 
in parallel to improve efficiency. You can use Promise.all() 
to wait for all operations to complete before proceeding.

async function fetchAllData() {
    try {
        const [usersResponse, postsResponse, commentsResponse] = await Promise.all([
            fetch('https://jsonplaceholder.typicode.com/users'),
            fetch('https://jsonplaceholder.typicode.com/posts'),
            fetch('https://jsonplaceholder.typicode.com/comments')
        ]);

        const users = await usersResponse.json();
        const posts = await postsResponse.json();
        const comments = await commentsResponse.json();

        console.log('Users:', users);
        console.log('Posts:', posts);
        console.log('Comments:', comments);
    } catch (error) {
        console.error('Error fetching data:', error);
    }
}

fetchAllData();

In this example:

Promise.all() runs all the fetch operations in parallel, 
which can be more efficient when the operations are 
independent of each other.

Real-Time Features with WebSockets
WebSockets provide a way to open a persistent connection 
between the client and the server, allowing for real-time, 
two-way communication. This is particularly useful for 
applications like chat systems, live notifications, and 
online gaming.

Setting Up a WebSocket Server
For demonstration purposes, let’s assume you have a simple 
WebSocket server running with Node.js.

server.js

const WebSocket = require('ws');
const server = new WebSocket.Server({ port: 8080 });

server.on('connection', ws => {
    console.log('New client connected');

    ws.on('message', message => {
        console.log('Received:', message);
        ws.send(`Server: You said "${message}"`);
    });

    ws.on('close', () => {
        console.log('Client disconnected');
    });
});

In this example:

A WebSocket server is created using the ws library, 
which listens on port 8080.

The server responds to messages from the client and 
sends back a confirmation message.

Connecting to a WebSocket Server from the Client
Now, let’s create a client-side script to connect to 
this WebSocket server.

index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Example</title>
</head>

<body>
    <h1>WebSocket Chat</h1>
    <input type="text" id="message" placeholder="Type a message">

    <button id="send">Send</button>

    <div id="chat"></div>

    <script src="websocket.js"></script>
</body>
</html>

websocket.js

const ws = new WebSocket('ws://localhost:8080');

ws.onopen = () => {
    console.log('Connected to the server');
};

ws.onmessage = event => {
    const chat = document.getElementById('chat');
    const message = document.createElement('p');

    message.textContent = event.data;
    chat.appendChild(message);
};

ws.onclose = () => {
    console.log('Disconnected from the server');
};

document.getElementById('send').addEventListener('click', () => {
    const input = document.getElementById('message');
    ws.send(input.value);

    input.value = '';
});

In this client-side script:
A WebSocket connection is established to the server.

Messages can be sent to the server, and responses from 
the server are displayed in the chat window.

Handling Asynchronous Flows with async/await and 
Promise.allSettled

When dealing with multiple asynchronous operations, some 
of which may fail, Promise.allSettled() is useful. It 
waits for all promises to settle (either resolved or 
rejected) and returns an array of objects describing the 
outcome of each promise.

Example: Using Promise.allSettled()

async function fetchData() {
    const results = await Promise.allSettled([
        fetch('https://jsonplaceholder.typicode.com/users'),
        fetch('https://jsonplaceholder.typicode.com/invalid-endpoint'),
        fetch('https://jsonplaceholder.typicode.com/posts')
    ]);

    results.forEach(result => {
        if (result.status === 'fulfilled') {
            console.log('Success:', result.value);
        } else {
            console.error('Failed:', result.reason);
        }
    });
}

fetchData();

In this example:
Promise.allSettled() allows you to handle both successful 
and failed promises without terminating the entire process 
due to one failure.

Practical Exercise: 
Creating a Real-Time Chat Application

Let’s put together what we’ve learned by creating a simple 
real-time chat application using WebSockets.

server.js

const WebSocket = require('ws');
const server = new WebSocket.Server({ port: 8080 });

server.on('connection', ws => {
    console.log('New client connected');

    ws.on('message', message => {
        console.log('Received:', message);

        server.clients.forEach(client => {
            if (client.readyState === WebSocket.OPEN) {
                client.send(message);
            }
        });
    });

    ws.on('close', () => {
        console.log('Client disconnected');
    });
});

index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Chat</title>
</head>

<body>
    <h1>Real-Time Chat</h1>
    <input type="text" id="message" placeholder="Type a message">
    <button id="send">Send</button>
    <div id="chat"></div>

    <script src="chat.js"></script>
</body>
</html>

chat.js

const ws = new WebSocket('ws://localhost:8080');

ws.onopen = () => {
    console.log('Connected to the server');
};

ws.onmessage = event => {
    const chat = document.getElementById('chat');
    const message = document.createElement('p');
    message.textContent = event.data;
    chat.appendChild(message);
};

ws.onclose = () => {
    console.log('Disconnected from the server');
};

document.getElementById('send').addEventListener('click', () => {
    const input = document.getElementById('message');
    ws.send(input.value);

    input.value = '';
});

In this project:
A WebSocket server broadcasts messages to all connected clients, 
enabling real-time communication.

Clients can send and receive messages instantly, with updates 
displayed in the chat window.

Summary
Advanced asynchronous programming techniques in JavaScript 
are essential for building robust, real-time, and highly 
interactive applications. By mastering async/await, handling 
complex asynchronous flows, and implementing WebSockets for 
real-time communication, you can create powerful, responsive 
applications that provide seamless user experiences. These 
skills are critical as you tackle more sophisticated projects 
in modern web development.


4. Performance Optimization

Performance optimization is a crucial aspect of web development, 
ensuring that your applications run efficiently and provide a 
smooth user experience. This lesson focuses on understanding how 
to optimize memory usage, improve JavaScript execution speed, 
and apply best practices for writing efficient code.

Understanding and Optimizing Memory Usage
JavaScript applications can consume a significant amount of memory, 
especially when dealing with large datasets or complex operations. 
Understanding how to manage and optimize memory usage is essential 
to prevent memory leaks and improve performance.

Memory Management Basics
JavaScript automatically allocates and deallocates memory for 
objects, but poor memory management can lead to memory 
leaks—situations where memory that is no longer needed is not 
released.

Example: Memory Leak with Closures

function createMemoryLeak() {
    const largeArray = new Array(1000000).fill('Leak');

    return function() {
        console.log(largeArray.length);
    };
}

const leak = createMemoryLeak();
// Even after 'leak' is no longer needed, 'largeArray' remains 
in memory

In this example:
The largeArray remains in memory even after it is no longer 
needed, causing a memory leak.

Avoiding Memory Leaks
Remove Event Listeners: 
Ensure that event listeners are properly removed when they are 
no longer needed.

const button = document.getElementById('myButton');
button.addEventListener('click', handleClick);

// Later, remove the event listener to free up memory
button.removeEventListener('click', handleClick);

Nullify References: 
Set references to null when an object is no longer needed.

let obj = { key: 'value' };
obj = null; // Dereference the object, allowing garbage collection

Avoid Global Variables: 
Limit the use of global variables to avoid unnecessary memory 
retention.

Improving JavaScript Execution Speed
JavaScript execution speed can significantly impact the 
performance of your application, particularly for CPU-intensive 
tasks. Optimizing your code for speed ensures a better user 
experience.

Minimizing DOM Manipulations
Frequent DOM manipulations are expensive in terms of performance. 
To improve execution speed, batch DOM updates and minimize reflows 
and repaints.

Example: Inefficient DOM Manipulation

const list = document.getElementById('list');

for (let i = 0; i < 1000; i++) {
    const listItem = document.createElement('li');
    listItem.textContent = `Item ${i}`;

    list.appendChild(listItem); // Causes 1000 reflows
}

Example: Efficient DOM Manipulation

const list = document.getElementById('list');
const fragment = document.createDocumentFragment();

for (let i = 0; i < 1000; i++) {
    const listItem = document.createElement('li');
    listItem.textContent = `Item ${i}`;

    fragment.appendChild(listItem); // No reflow yet
}

list.appendChild(fragment); // Single reflow for all items

In this example:
Using a DocumentFragment minimizes reflows by batching DOM 
updates.

Optimizing Loops and Iterations
Loops are common in JavaScript, but inefficient loops can 
slow down your application. Use techniques like caching 
loop lengths or using the most efficient loop type for your 
needs.

Example: Loop Optimization

// Inefficient: Recalculates array length on each iteration
for (let i = 0; i < array.length; i++) {
    process(array[i]);
}

// Efficient: Cache array length
for (let i = 0, len = array.length; i < len; i++) {
    process(array[i]);
}

Debouncing and Throttling
Debouncing and throttling are techniques used to limit the 
number of times a function is executed, particularly in 
response to events like scrolling or resizing.

Example: Debouncing

function debounce(fn, delay) {
    let timeoutID;

    return function(...args) {
        if (timeoutID) clearTimeout(timeoutID);

        timeoutID = setTimeout(() => fn.apply(this, args), delay);
    };
}

const handleScroll = debounce(() => {
    console.log('Scroll event handled');
}, 200);

window.addEventListener('scroll', handleScroll);

Example: Throttling

function throttle(fn, limit) {
    let lastCall = 0;

    return function(...args) {
        const now = Date.now();

        if (now - lastCall >= limit) {
            lastCall = now;

            fn.apply(this, args);
        }
    };
}

const handleResize = throttle(() => {
    console.log('Resize event handled');
}, 200);

window.addEventListener('resize', handleResize);

In these examples:
Debouncing ensures that the event handler is called only after 
the event has stopped firing for a specified time.

Throttling ensures that the event handler is called at most 
once within a specified time interval.

Best Practices for Writing Efficient Code
Writing efficient JavaScript code involves following best 
practices that reduce complexity, improve readability, and 
enhance performance.

Avoiding Deep Nesting
Deeply nested code can be hard to read and maintain. Flatten 
your code structure where possible to improve clarity and 
performance.

Example: Avoiding Deep Nesting

// Inefficient and hard to read
if (condition1) {
    if (condition2) {
        if (condition3) {
            // Code
        }
    }
}

// Better approach
if (!condition1) return;
if (!condition2) return;
if (!condition3) return;
// Code

Using Modern JavaScript Features
Take advantage of modern JavaScript features like let, const,
arrow functions, and template literals for cleaner and more 
efficient code.

Example: Using let and const

// Old approach
var name = 'Alice';
name = 'Bob';

// Modern approach
const name = 'Alice'; 
// Use const when the variable won't be reassigned

let age = 30;
age = 31;

Minimizing Recalculation
Avoid recalculating values or expressions that do not change 
during the execution of your code.

Example: Minimizing Recalculation

// Inefficient: Recalculates the same value multiple times
let result = (a + b) * (a + b);

// Efficient: Calculate once and reuse the result
const sum = a + b;
let result = sum * sum;

Practical Exercise: 
Optimizing a JavaScript Application

Let’s apply some of these performance optimization techniques 
to a simple JavaScript application that renders a list of 
items and handles user interactions.

index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Optimized App</title>
</head>

<body>
    <h1>Item List</h1>
    <button id="addItem">Add 1000 Items</button>
    <ul id="itemList"></ul>

    <script src="app.js"></script>
</body>
</html>

app.js

document.getElementById('addItem').addEventListener('click', () => {
    const itemList = document.getElementById('itemList');
    const fragment = document.createDocumentFragment();

    for (let i = 0; i < 1000; i++) {
        const listItem = document.createElement('li');
        listItem.textContent = `Item ${i}`;
        fragment.appendChild(listItem);
    }

    itemList.appendChild(fragment); // Batch DOM updates
});

// Efficient event handling with throttling
function throttle(fn, limit) {
    let lastCall = 0;

    return function(...args) {
        const now = Date.now();

        if (now - lastCall >= limit) {
            lastCall = now;
            fn.apply(this, args);
        }
    };
}

window.addEventListener('resize', throttle(() => {
    console.log('Window resized');
}, 200));

In this example:
The app adds 1000 items to a list with optimized DOM manipulation 
using a DocumentFragment.

Event handling for the window resize event is optimized using 
throttling.

Summary
Performance optimization in JavaScript involves a variety of 
techniques, from managing memory usage and improving execution 
speed to applying best practices in writing efficient code. 
By understanding and implementing these optimization strategies, 
you can build faster, more responsive applications that deliver 
a superior user experience. As you continue to develop more 
complex applications, performance optimization will become an 
integral part of your development process.


5. Testing and Debugging JavaScript

Testing and debugging are essential practices in software 
development that help ensure your code is reliable, maintainable, 
and free of bugs. In this lesson, we’ll cover how to write unit 
tests for JavaScript functions, use debugging tools, and follow 
best practices to maintain high code quality.

Writing Unit Tests for JavaScript Functions
Unit testing involves testing individual units or components of 
a program to ensure they work as expected. In JavaScript, unit 
tests are typically written using testing frameworks like Jest, 
Mocha, or Jasmine.

Setting Up a Testing Environment
To get started with unit testing in JavaScript, you need to set 
up a testing environment. Here, we'll use Jest, a popular testing 
framework.

Step 1: Install Jest
First, install Jest via npm:

npm install --save-dev jest

Step 2: Create a Test File
Create a test file for the JavaScript function you want to test. 
Test files are usually named with a .test.js or .spec.js extension.

// sum.js - Function to be tested
function sum(a, b) {
    return a + b;
}

module.exports = sum;

// sum.test.js - Test file
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
});

test('adds -1 + 1 to equal 0', () => {
    expect(sum(-1, 1)).toBe(0);
});

Step 3: Run the Tests

Add a test script to your package.json file:

{
    "scripts": {
        "test": "jest"
    }
}

Run the tests using the following command:

npm test

In this example:
The sum function is tested with two cases: adding positive 
numbers and adding a positive and negative number.

Jest provides the test function to define test cases, and 
the expect function to create assertions.

Using Debugging Tools in Modern Browsers
Modern browsers like Chrome, Firefox, and Edge come with 
powerful built-in developer tools that you can use to debug 
JavaScript code.

Accessing Developer Tools
To open developer tools in most browsers, press F12 or 
Ctrl + Shift + I (or Cmd + Option + I on macOS). The developer 
tools typically include the following panels:

Elements: 
Inspect and modify the HTML and CSS of a webpage.

Console: 
View and log JavaScript outputs, errors, and warnings.

Sources: 
Debug JavaScript by setting breakpoints, stepping through code, 
and inspecting variables.

Network: 
Monitor network requests and responses.

Using the Console for Debugging
The console is one of the most commonly used tools for 
debugging JavaScript. You can log values, check for errors, 
and perform calculations directly in the console.

Example: Logging Output

const user = { name: 'Alice', age: 25 };
console.log(user); // Logs the user object to the console

Example: Inspecting Errors
console.error('Something went wrong!'); 
// Logs an error message to the console

Using Breakpoints and Step Debugging
Breakpoints allow you to pause the execution of your code 
at a specific line, enabling you to inspect the current 
state of your application.

Example: Setting a Breakpoint

Open the Sources panel in the developer tools.

Navigate to the JavaScript file you want to debug.

Click on the line number where you want to set a breakpoint.

When the code execution reaches the breakpoint, it will pause, 
allowing you to step through the code line by line, inspect 
variables, and evaluate expressions.

Using Conditional Breakpoints
You can set breakpoints that only trigger when certain 
conditions are met, which is useful for debugging loops 
or complex conditions.

Example: Setting a Conditional Breakpoint

Right-click on the line number in the Sources panel.

Select "Add conditional breakpoint."

Enter the condition, such as index === 5.

The breakpoint will only trigger when the condition is true.

Best Practices for Maintaining High Code Quality
Maintaining high code quality is crucial for developing reliable 
and maintainable software. Following best practices helps prevent 
bugs, reduces technical debt, and makes your code easier to 
understand.

1. Write Tests for Critical Code Paths
Ensure that critical parts of your application are covered 
by unit tests. This includes core business logic, data 
processing, and any code that is prone to errors.

2. Use Linting Tools
Linting tools like ESLint help enforce coding standards and 
catch potential errors before they become issues.

Example: Setting Up ESLint

Install ESLint:
npm install --save-dev eslint

Initialize ESLint in your project:
npx eslint --init

Run ESLint to check your code:
npx eslint yourfile.js

3. Keep Functions Small and Focused
Write functions that perform a single task. This makes your 
code more modular, easier to test, and easier to understand.

Example: Refactoring a Large Function

// Large function
function processOrder(order) {
    validateOrder(order);
    calculateTotal(order);
    applyDiscounts(order);
    saveOrder(order);
}

// Refactored into smaller functions

function validateOrder(order) {
    // Validation logic
}

function calculateTotal(order) {
    // Calculation logic
}

function applyDiscounts(order) {
    // Discount logic
}

function saveOrder(order) {
    // Save logic
}


4. Use Descriptive Variable and Function Names
Choose variable and function names that clearly describe 
their purpose. This makes your code more readable and 
easier to maintain.

Example: Descriptive Naming

// Bad naming
let x = 10;

function foo() {
    return x * 2;
}

// Good naming
let userAge = 10;

function doubleUserAge() {
    return userAge * 2;
}


5. Document Your Code
Use comments and documentation to explain complex logic, 
provide context, and guide future developers who may work 
on your code.

Example: Commenting Complex Logic

/**
 * Calculates the total price of the order, including 
 * discounts and taxes.
 * @param {Object} order - The order object containing items 
 * and quantities.
 * @returns {number} The total price.
 */

function calculateTotalPrice(order) {
    // Logic to calculate total price
}

Practical Exercise: 
Writing and Debugging Tests

Let’s practice writing and debugging a unit test for a simple 
JavaScript function.

index.js

function multiply(a, b) {
    if (typeof a !== 'number' || typeof b !== 'number') {
        throw new Error('Both arguments must be numbers');
    }

    return a * b;
}

module.exports = multiply;

index.test.js

const multiply = require('./index');

test('multiplies 2 * 3 to equal 6', () => {
    expect(multiply(2, 3)).toBe(6);
});

test('throws an error when non-number arguments are provided', () => {
    expect(() => multiply(2, 'three')).toThrow('Both arguments must be numbers');
});

Debugging with Jest

Run the tests using npm test.

If a test fails, use console.log or breakpoints to inspect 
the function's behavior.

Fix the issue and re-run the tests until all pass.

In this exercise:
We wrote a unit test for the multiply function to verify its 
correct behavior.

We handled both successful cases and error cases in the tests.

Summary
Testing and debugging are critical practices for ensuring the 
quality and reliability of your JavaScript code. By writing 
unit tests, using debugging tools effectively, and following 
best practices, you can catch errors early, maintain high 
code quality, and build robust applications. As you continue 
to develop more complex software, these skills will become 
increasingly important for delivering high-quality products.

-->
