<!-- 
A. Introduction to JS
=====================


1. What is JavaScript?

Definition:
JavaScript is a high-level, interpreted programming
language primarily used to add interactivity to web
pages. It enables developers to create dynamic content
that can respond to user actions, such as clicks, 
input, or mouse movements.

Role in Web Development:
JavaScript is one of the core technologies of the web,
alongside HTML and CSS. While HTML provides the 
structureand CSS handles the styling, JavaScript is 
responsible for the behavior of web pages. It allows 
for the manipulation of the Document Object Model (DOM),
making it possible to update content, validate forms, 
create animations, and much more, without needing to 
reload the entire page.


2. Setting Up Your Development Environment

Introduction to Code Editors:
A code editor is a specialized text editor designed 
for writing and editing code, offering features like 
syntax highlighting, code completion, and debugging 
tools.

Popular code editors include Visual Studio Code (VS Code), 
Sublime Text, Atom, and others.

Key Features of Browser Developer Tools:
Console: 
A command-line interface to interact with JavaScript, log
information using console.log(), and debug scripts.

Elements Panel: 
Allows inspection and modification of HTML and CSS in real-time, 
understanding the Document Object Model (DOM), and testing code
changes without editing source files.

Sources Panel: 
View, edit, and debug JavaScript files, set breakpoints, and step
through code execution.

Network Panel: 
Monitor network requests and analyze loading times to optimize
performance.


3. JavaScript Basics

What Are Variables?
Variables are used to store data values in JavaScript. They 
act as containers that hold information that can be referenced 
and manipulated throughout your code.

Declaring Variables:
Variables in JavaScript can be declared using var, let, or const.

var: 
An older way to declare variables; 
function-scoped.

let: 
A modern way to declare variables; 
block-scoped.

const: 
Used to declare constants that cannot be reassigned; 
block-scoped.

Example:
var x = 10;      // Declares a variable x with value 10
let name = "Bob"; // Declares a block-scoped variable name 
with value "Bob"
const PI = 3.14; // Declares a constant PI with value 3.14

Data Types in JavaScript
Primitive Data Types:
String: 
Textual data enclosed in quotes (single or double).

Number: 
Numeric values (integers and floats).

Boolean: 
Represents true or false.

Undefined: 
A variable that has been declared but not assigned a value.

Null: 
Represents the intentional absence of any object value.

Symbol: 
Represents a unique and immutable value (introduced in ES6).

BigInt: 
For working with large integers.

Example of Data Types:

let age = 25;           // Number
let greeting = "Hello"; // String
let isStudent = false;  // Boolean
let city;               // Undefined
let salary = null;      // Null


Understanding Operators

Arithmetic Operators:
Perform basic mathematical operations.
+ Addition
- Subtraction
* Multiplication
/ Division
% Modulus (remainder)
** Exponentiation

Assignment Operators:
Assign values to variables.
= Assignment
+= Add and assign
-= Subtract and assign
*= Multiply and assign
/= Divide and assign

Comparison Operators:
Compare two values and return a Boolean (true or false).

== Equal to
=== Strictly equal (same value and type)
!= Not equal to
!== Strictly not equal
> Greater than
< Less than
>= Greater than or equal to
<= Less than or equal to

Logical Operators:
Combine multiple conditions.
&& Logical AND
|| Logical OR
! Logical NOT

Example of Using Operators:

let a = 10;
let b = 20;
let sum = a + b;           // 30 (Addition)
let isEqual = a == b;      // false (Comparison)
let bothTrue = (a < b) && (b > 15); // true (Logical)


Writing Simple Expressions and Statements

Expressions:
An expression is a combination of values, variables, and 
operators that produces a value.

Example:
let c = 5 * (2 + 3);  // c is assigned the value 25

Statements:
A statement is an instruction that performs an action.

Example:
let greeting = "Hello, World!"; // This is a statement


Introduction to Comments

Single-Line Comments:
Created using // at the beginning of the comment line.

Example:

// This is a single-line comment
let x = 10;  // This comment is at the end of a statement


Multi-Line Comments:
Created using /* to start and */ to end the comment block.

Example:

/* This is a
   multi-line comment */
let y = 20;

Best Practices for Writing Clean Code
Use Descriptive Variable Names:
Choose meaningful names that describe the purpose of the 
variable.

Example:
let totalPrice = 100;

Keep Code DRY (Don't Repeat Yourself):
Avoid duplicating code by using functions or loops.

Comment Wisely:
Use comments to explain complex logic, but avoid 
over-commenting.

Consistent Indentation:
Properly indent code to enhance readability.

Avoid Global Variables:
Minimize the use of global variables to prevent conflicts.


4. Control Flow
is a fundamental concept in programming that determines the 
order in which statements and instructions are executed. In 
JavaScript, control flow allows you to make decisions, 
repeat tasks, and execute different blocks of code based on 
specific conditions. This lesson will explore the essential 
control flow structures in JavaScript: conditional statements 
and loops.

Conditional Statements
are the backbone of decision-making in JavaScript. They allow 
your program to execute certain code blocks only when specific 
conditions are met. The main types of conditional statements 
in JavaScript include if, else if, else, and switch.

if Statement
The if statement is the most basic form of conditional statement. 
It executes a block of code if the condition provided evaluates 
to true. If the condition is false, the code inside the if block 
is skipped.

Syntax:

if (condition) {
    // Code to execute if condition is true
}

Example:

let age = 18;

if (age >= 18) {
    console.log("You are eligible to vote.");
}

In this example, the condition age >= 18 is evaluated. Since the 
condition is true, the message "You are eligible to vote." is 
printed to the console.

else Statement
The else statement complements the if statement. It allows you 
to define a block of code that will execute if the if condition 
evaluates to false. This provides a fallback option when the 
initial condition isn't met.

Syntax:

if (condition) {
    // Code to execute if condition is true
} else {
    // Code to execute if condition is false
}

Example:

let age = 16;

if (age >= 18) {
    console.log("You are eligible to vote.");
} else {
    console.log("You are not eligible to vote.");
}

Here, the condition age >= 18 is false, so the message "You 
are not eligible to vote." is printed.

else if Statement
The else if statement allows you to test multiple conditions 
in sequence. If the first if condition is false, the program 
checks the next else if condition, and so on. This is useful 
for handling more than two possible outcomes.

Syntax:

if (condition1) {
    // Code to execute if condition1 is true
} else if (condition2) {
    // Code to execute if condition2 is true
} else {
    // Code to execute if all conditions are false
}

Example:

let score = 75;

if (score >= 90) {
    console.log("Grade: A");
} else if (score >= 80) {
    console.log("Grade: B");
} else if (score >= 70) {
    console.log("Grade: C");
} else if (score >= 60) {
    console.log("Grade: D");
} else {
    console.log("Grade: F");
}

In this example, the else if chain checks the score 
variable against multiple thresholds. The first 
condition that evaluates to true dictates the output, 
so "Grade: C" is printed.

switch Statement
The switch statement is a more organized way to compare 
a variable against multiple values. It's often used when 
you have a single variable that needs to be compared 
against several different cases. Each case in a switch 
statement is followed by a colon and the code to execute. 
The break statement is used to exit the switch block 
once a matching case is found.

Syntax:

switch (expression) {
    case value1:
        // Code to execute if expression === value1
        break;
    case value2:
        // Code to execute if expression === value2
        break;
        // Add more cases as needed
    default:
        // Code to execute if none of the cases match
}

Example:

let day = 3;
let dayName;

switch (day) {
    case 1:
        dayName = "Sunday";
        break;

    case 2:
        dayName = "Monday";
        break;

    case 3:
        dayName = "Tuesday";
        break;

    case 4:
        dayName = "Wednesday";
        break;

    case 5:
        dayName = "Thursday";
        break;

    case 6:
        dayName = "Friday";
        break;

    case 7:
        dayName = "Saturday";
        break;

    default:
        dayName = "Invalid day";
}

console.log(dayName);

In this example, the day variable is compared against 
each case. Since day equals 3, the dayName is set to 
"Tuesday", and this value is printed to the console.
The default case handles any values that don't match 
the listed cases.

Looping Structures
Loops are used to repeat a block of code multiple times, 
epending on certain conditions. JavaScript provides three 
main types of loops: for, while, and do...while.

for Loop
The for loop is a powerful and flexible loop structure that 
is used when you know how many times you want to iterate over 
a block of code. It consists of three parts: initialization, 
condition, and increment/decrement.

Syntax:

for (initialization; condition; increment) {
    // Code to be executed in each iteration
}

Example:

for (let i = 0; i < 5; i++) {
    console.log("Iteration number " + i);
}

In this example, the loop starts with i = 0 (initialization), 
runs as long as i < 5 (condition), and increments i by 1 after 
each iteration (i++). The loop will print the iteration number 
from 0 to 4.

while Loop
The while loop is used when you want to repeat a block of code 
as long as a specified condition remains true. Unlike the for 
loop, the while loop does not have a built-in counter, so you 
need to manage the loop's control variable manually.

Syntax:

while (condition) {
    // Code to be executed as long as condition is true
}

Example:

let i = 0;

while (i < 5) {
    console.log("Iteration number " + i);
    i++;
}

In this example, the loop runs as long as i < 5. The variable 
i is incremented with each iteration, printing numbers 0 to 4. 
The loop stops when i equals 5.

do...while Loop
The do...while loop is similar to the while loop, but with a 
key difference: it guarantees that the code block inside the 
loop is executed at least once, even if the condition is false 
from the start. This is because the condition is checked after 
the loop has run.

Syntax:

do {
    // Code to be executed
} while (condition);


Example:

let i = 0;

do {
    console.log("Iteration number " + i);
    i++;
} while (i < 5);

In this example, the loop will print numbers 0 to 4, just 
like the previous loops. However, even if i started with 
a value of 5, the loop would still execute once before 
checking the condition.

Breaking and Continuing Loops
JavaScript provides two special statements to control the 
flow of loops: break and continue.

break Statement
The break statement is used to exit a loop immediately, 
regardless of the loop's condition. This is useful when 
you need to stop the loop early based on a specific 
condition.

Example:

for (let i = 0; i < 10; i++) {
    if (i === 5) {
        break; // Exit the loop when i equals 5
    }
    console.log(i);
}

In this example, the loop will print numbers from 0 to 4. 
When i equals 5, the break statement terminates the loop, 
so the loop does not continue to 10.

continue Statement
The continue statement skips the current iteration of the 
loop and moves on to the next iteration. This is useful 
when you want to skip over certain values or conditions 
without stopping the loop entirely.

Example:

for (let i = 0; i < 10; i++) {
    if (i === 5) {
        continue; // Skip the iteration when i equals 5
    }
    console.log(i);
}

In this example, the loop prints numbers from 0 to 9, except 
for 5. When i equals 5, the continue statement causes the 
loop to skip that iteration, so 5 is not printed.


5. Functions

Functions are a foundational concept in JavaScript. They allow 
you to encapsulate blocks of code that can be reused throughout 
your program, making your code more modular, readable, and 
maintainable. In this lesson, we'll dive into defining functions, 
invoking them, using parameters and return values, and 
understanding the scope of variables within functions.

Defining and Invoking Functions

Defining a Function
A function in JavaScript is defined using the function keyword, 
followed by a name, a list of parameters (optional), and a block 
of code that the function will execute.

Syntax:

function functionName(parameters) {
    // Code to be executed
}

Example:

function greet() {
    console.log("Hello, world!");
}

In this example, we've defined a function named greet that, 
when called, will print "Hello, world!" to the console.

Invoking a Function
To execute the code within a function, you need to invoke 
(or call) the function by using its name followed by 
parentheses.

Example:

greet(); // Outputs: Hello, world!

Here, the greet function is invoked, and the message 
"Hello, world!" is printed to the console.

Function Parameters and Return Values

Parameters
Parameters are inputs that you can pass to a function to 
customize its behavior. They act as placeholders for the 
values that will be passed to the function when it is 
invoked.

Example:

function greetUser(name) {
    console.log("Hello, " + name + "!");
}

greetUser("Alice"); // Outputs: Hello, Alice!

In this example, the greetUser function accepts a parameter 
name and uses it to personalize the greeting.

Return Values
A function can also return a value to the code that called 
it, using the return statement. This allows the function to 
produce an output that can be stored in a variable or used 
in other parts of your program.

Example:

function add(a, b) {
    return a + b;
}

let sum = add(5, 3); // sum will be 8
console.log(sum); // Outputs: 8

Here, the add function takes two parameters, a and b, adds 
them together, and returns the result. The returned value 
is then stored in the variable sum.

Understanding Scope

Scope determines the visibility and accessibility of variables 
within different parts of your program. JavaScript has two 
main types of scope: local and global.

Local Scope
A variable declared inside a function has local scope, meaning 
t is only accessible within that function.

Example:

function multiply(x, y) {
    let result = x * y;
    return result;
}

console.log(result); // Error: result is not defined

In this example, the result variable is declared inside the 
multiply function, so it is not accessible outside the 
function.

Global Scope
A variable declared outside any function has global scope, 
meaning it is accessible throughout your entire program.

Example:

let globalVar = "I am global";

function showGlobalVar() {
    console.log(globalVar);
}

showGlobalVar(); // Outputs: I am global

Here, globalVar is accessible both inside and outside the 
showGlobalVar function because it is globally scoped.

Best Practices for Writing Functions
Keep functions small and focused: Each function should 
perform a single task or a small set of closely related 
tasks. This makes your functions easier to understand, 
test, and reuse.

Use meaningful names: 
Function names should clearly describe what the function does. 
This makes your code more readable.

Avoid side effects: 
Functions should avoid modifying variables or states outside 
their scope unless absolutely necessary. This reduces unintended 
consequences and bugs.

Document your functions: 
Include comments or documentation to explain what each function 
does, what parameters it takes, and what it returns.

By mastering functions, you'll be able to write more efficient, 
modular, and maintainable JavaScript code. Functions are a 
powerful tool in your programming toolbox, and understanding 
them deeply will greatly enhance your ability to build complex 
applications.


B. Working With Data In JS
==========================

1. Arrays

Introduction to Arrays
An array in JavaScript is a special type of object used to 
store multiple values in a single variable. Arrays are 
ordered collections, meaning each item has a specific position 
(index) within the array. They are incredibly versatile and 
are used extensively in JavaScript programming for managing 
lists of data.

Creating Arrays
There are two main ways to create an array in JavaScript:

1. Array Literal Notation: 
This is the most straightforward way to create an array. You 
simply enclose a comma-separated list of values in square 
brackets.

Example:
let fruits = ['apple', 'banana', 'orange'];

2. Array Constructor: 
You can also use the Array() constructor to create an array. 
This method is less common but can be useful in certain 
situations.

Example:
let numbers = new Array(1, 2, 3, 4, 5);

Accessing Array Elements
Array elements are accessed using their index. In JavaScript, 
array indices start at 0. This means the first element is at 
index 0, the second at index 1, and so on.

Example:
let fruits = ['apple', 'banana', 'orange'];

console.log(fruits[0]); // Outputs: 'apple'
console.log(fruits[2]); // Outputs: 'orange'


Array Properties and Basic Methods
length Property: 
The length property returns the number of elements in an array.

Example:
let fruits = ['apple', 'banana', 'orange'];

console.log(fruits.length); // Outputs: 3

push() Method: 
The push() method adds one or more elements to the end of 
an array and returns the new length of the array.

Example:
let fruits = ['apple', 'banana'];
fruits.push('orange');

console.log(fruits); // Outputs: ['apple', 'banana', 'orange']

pop() Method: 
The pop() method removes the last element from an array 
and returns that element.

Example:
let fruits = ['apple', 'banana', 'orange'];
let lastFruit = fruits.pop();

console.log(lastFruit); // Outputs: 'orange'
console.log(fruits); // Outputs: ['apple', 'banana']

Array Manipulation
Adding Elements: 
Besides push(), you can add elements to specific positions 
using the index:

let fruits = ['apple', 'banana'];
fruits[2] = 'orange'; // Adds 'orange' at index 2
fruits[10] = 'grape'; // Creates empty slots and adds 'grape' at index 10

Removing Elements: 
The splice() method can be used to remove elements from 
any position in the array:

let fruits = ['apple', 'banana', 'orange', 'grape'];
fruits.splice(1, 2); // Removes 2 elements starting from index 1

console.log(fruits); // Outputs: ['apple', 'grape']

Iterating Through Arrays
There are several ways to iterate through arrays in JavaScript:

for Loop: 
The traditional for loop is often used for array iteration.

Example:

let fruits = ['apple', 'banana', 'orange'];
for (let i = 0; i < fruits.length; i++) {
    console.log(fruits[i]);
}

forEach() Method: 
The forEach() method executes a provided function once for 
each array element.

Example:

let fruits = ['apple', 'banana', 'orange'];
fruits.forEach(function(fruit) {
    console.log(fruit);
});

for...of Loop: 
Introduced in ES6, the for...of loop provides a simpler 
syntax for iterating over iterable objects like arrays.

Example:

let fruits = ['apple', 'banana', 'orange'];
for (let fruit of fruits) {
    console.log(fruit);
}

Common Array Methods

map(): 
The map() method creates a new array with the results of 
calling a provided function on every element in the array.

Example:

let numbers = [1, 2, 3, 4, 5];
let squared = numbers.map(function(num) {
    return num * num;
});

console.log(squared); // Outputs: [1, 4, 9, 16, 25]

filter(): 
The filter() method creates a new array with all elements 
that pass the test implemented by the provided function.

Example:

let numbers = [1, 2, 3, 4, 5, 6];
let evenNumbers = numbers.filter(function(num) {
    return num % 2 === 0;
});

console.log(evenNumbers); // Outputs: [2, 4, 6]

reduce(): 
The reduce() method executes a reducer function on each 
element of the array, resulting in a single output value.

Example:

let numbers = [1, 2, 3, 4, 5];
let sum = numbers.reduce(function(accumulator, currentValue) {
    return accumulator + currentValue;
}, 0);

console.log(sum); // Outputs: 15

Understanding arrays and their methods is crucial in 
JavaScript programming. They provide powerful tools for 
managing and manipulating collections of data efficiently. 
Practice working with arrays and their methods to become 
proficient in using them in your JavaScript programs.


2. Objects

Introduction to Objects and Key-Value Pairs
Objects are one of the most fundamental and powerful concepts 
in JavaScript. They allow you to store collections of related 
data and functionality in a single container. Unlike arrays, 
which use numeric indices, objects use keys to access their 
members.

An object in JavaScript is a collection of key-value pairs. 
Each key-value pair is called a property:

The key is always a string (or a Symbol in ES6+).

The value can be any valid JavaScript data type, including 
numbers, strings, arrays, functions, and even other objects.

Basic Object Syntax
Here's the basic syntax for creating an object:

let person = {
    name: "John Doe",
    age: 30,
    isStudent: false
};

In this example:
person is the object
name, age, and isStudent are keys (also called property names)
"John Doe", 30, and false are the corresponding values

Creating and Accessing Object Properties

Creating Objects
There are several ways to create objects in JavaScript:

Object Literal Notation (as shown above):

let car = {
    brand: "Toyota",
    model: "Corolla",
    year: 2022
};

Using the new Keyword with Object() Constructor:

let bike = new Object();
bike.type = "Mountain Bike";
bike.gears = 21;

Using Object Constructor Functions:

function Book(title, author) {
    this.title = title;
    this.author = author;
}

let myBook = new Book("1984", "George Orwell");

Accessing Object Properties

There are two main ways to access object properties:

Dot Notation:
console.log(car.brand);  // Outputs: Toyota

Bracket Notation:
console.log(car["model"]);  // Outputs: Corolla

Bracket notation is particularly useful when:
The property name is stored in a variable
The property name has special characters or starts with 
a number

Example:

let propertyName = "year";
console.log(car[propertyName]);  // Outputs: 2022

Adding and Modifying Properties
You can add new properties or modify existing ones after 
an object is created:

car.color = "blue";  // Adds a new property
car.year = 2023;     // Modifies an existing property


Deleting Properties
You can remove a property from an object using the delete 
operator:

delete car.color;
console.log(car.color);  // Outputs: undefined


Methods Within Objects
Methods are functions that are stored as object properties. 
They define the behavior of an object.

Defining Methods
You can define a method when creating an object:

let person = {
    name: "Alice",
    greet: function() {
        console.log("Hello, I'm " + this.name);
    }
};

person.greet();  // Outputs: Hello, I'm Alice

In ES6+, you can use a shorter syntax:

let person = {
    name: "Alice",

    greet() {
        console.log("Hello, I'm " + this.name);
    }
};

The this Keyword
In the context of an object method, this refers to 
the object the method belongs to. It allows methods 
to access and manipulate the object's properties.

let calculator = {
    value: 0,

    add(x) {
        this.value += x;
    },

    subtract(x) {
        this.value -= x;
    },

    getValue() {
        return this.value;
    }
};

calculator.add(5);
calculator.subtract(2);
console.log(calculator.getValue());  // Outputs: 3

Object Destructuring
ES6 introduced object destructuring, which provides a 
concise way to extract values from objects and assign 
them to variables:

let person = {
    name: "John",
    age: 30,
    city: "New York"
};

let { name, age } = person;

console.log(name);  // Outputs: John
console.log(age);   // Outputs: 30

You can also assign to different variable names:

let { name: personName, age: personAge } = person;

console.log(personName);  // Outputs: John
console.log(personAge);   // Outputs: 30

Conclusion
Objects are a cornerstone of JavaScript programming. They 
allow you to create complex data structures, organize your 
code, and model real-world entities in your programs. 
Understanding how to create, access, and manipulate objects 
is crucial for becoming proficient in JavaScript.

In the next lessons, we'll explore more advanced object 
concepts, including prototypes, inheritance, and ES6 
classes.


3. Working with Strings

Introduction to Strings in JavaScript
In JavaScript, a string is a sequence of characters used 
to represent text. Strings are one of the fundamental data 
types in JavaScript and are used extensively in web 
development for tasks such as displaying text on a webpage, 
processing user input, and manipulating textual data.

Creating Strings
There are three ways to create strings in JavaScript:

Single quotes:
let singleQuoted = 'Hello, World!';

Double quotes:
let doubleQuoted = "Hello, World!";

Template literals (backticks):
let templateLiteral = `Hello, World!`;

Single and double quotes are functionally identical. Template 
literals, introduced in ES6, offer more flexibility, allowing 
for multi-line strings and string interpolation.

String Properties

Length
The length property returns the number of characters in a 
string.

Example:

let text = "Hello";
console.log(text.length); // Outputs: 5


String Methods
JavaScript provides numerous built-in methods for manipulating 
and working with strings. Here are some of the most commonly 
used ones:

1. indexOf() and lastIndexOf()
These methods search for a specified substring within a string 
and return its position.

indexOf(): 
Searches from the beginning of the string.

lastIndexOf(): 
Searches from the end of the string.

Both return -1 if the substring is not found.

Example:

let str = "Hello, World!";
console.log(str.indexOf("o"));    // Outputs: 4
console.log(str.lastIndexOf("o")); // Outputs: 7

2. slice()
The slice() method extracts a portion of a string 
and returns it as a new string, without modifying 
the original string.

Syntax: str.slice(startIndex, endIndex)

Example:

let str = "Hello, World!";
console.log(str.slice(7, 12)); // Outputs: "World"
console.log(str.slice(7));     // Outputs: "World!"

3. substring()
Similar to slice(), but doesn't support negative indexes
and swaps arguments if startIndex is greater than 
endIndex.

Example:

let str = "Hello, World!";
console.log(str.substring(7, 12)); // Outputs: "World"

4. toLowerCase() and toUpperCase()
These methods convert a string to lowercase or uppercase 
respectively.

Example:

let str = "Hello, World!";
console.log(str.toLowerCase()); // Outputs: "hello, world!"
console.log(str.toUpperCase()); // Outputs: "HELLO, WORLD!"

5. trim()
The trim() method removes whitespace from both ends of a 
string.

Example:

let str = "   Hello, World!   ";
console.log(str.trim()); // Outputs: "Hello, World!"

6. replace()
The replace() method replaces a specified value with another
value in a string.

Example:

let str = "Hello, World!";
console.log(str.replace("World", "JavaScript")); // 
Outputs: "Hello, JavaScript!"

Note: 
By default, replace() only replaces the first occurrence. To 
replace all occurrences, use a regular expression with the 
global flag.

Template Literals and String Interpolation
Template literals, introduced in ES6, provide an easy way 
to create multi-line strings and to interpolate variables 
and expressions into strings.

Example:

let name = "Alice";
let age = 30;

let greeting = `Hello, my name is ${name} and I am ${age} years old.`;
console.log(greeting);
// Outputs: "Hello, my name is Alice and I am 30 years old."

Regular Expressions for Pattern Matching
Regular expressions (regex) are powerful tools for pattern 
matching and manipulation of strings. In JavaScript, you 
can create a regular expression using the RegExp constructor 
or regex literal notation.

Example:

// Using regex literal
let pattern = /hello/i;  // 'i' flag makes it case-insensitive

// Using RegExp constructor
let pattern = new RegExp("hello", "i");

let str = "Hello, World!";
console.log(pattern.test(str));  // Outputs: true

Common regex methods:

test(): 
Returns true if there's a match, false otherwise.

exec(): 
Returns an array of information if there's a match, or 
null otherwise.

match(): 
When used with a string, returns an array of matches.

Example of using regex with string methods:

let str = "The rain in Spain falls mainly in the plain";
let matches = str.match(/ain/g);
console.log(matches);  // Outputs: ["ain", "ain", "ain"]

Understanding how to work with strings effectively is 
crucial in JavaScript programming. Strings are used in 
almost every aspect of web development, from manipulating 
DOM content to processing user input and working with 
APIs. Regular practice with these methods and concepts 
will greatly enhance your ability to handle textual data 
in your JavaScript applications.


4. Numbers and Math

Understanding JavaScript Number Types
In JavaScript, all numbers are represented as 64-bit 
floating-point numbers, following the IEEE 754 standard. 
This means that JavaScript doesn't distinguish between 
integers and floating-point numbers - they're all treated 
as one number type.

Key points about JavaScript numbers:

No separate integer type: 
Unlike some other programming languages, JavaScript doesn't 
have a separate type for integers.

Precision limitations: 
Due to the floating-point representation, some decimal 
numbers can't be represented exactly, which can lead 
to precision errors in calculations.

Special number values: 
JavaScript has special number values like Infinity, 
-Infinity, and NaN (Not a Number).

Example:

let integer = 42;
let float = 3.14159;
let scientific = 5e3; // 5000 in scientific notation

console.log(typeof integer);  // Outputs: "number"
console.log(typeof float);    // Outputs: "number"
console.log(scientific);      // Outputs: 5000

Basic Arithmetic Operations
JavaScript supports all basic arithmetic operations: 
addition, subtraction, multiplication, division, and 
modulus (remainder).

Example:

let a = 10;
let b = 3;

console.log(a + b);  // Addition: 13
console.log(a - b);  // Subtraction: 7
console.log(a * b);  // Multiplication: 30
console.log(a / b);  // Division: 3.3333...
console.log(a % b);  // Modulus: 1

Increment and Decrement
JavaScript also provides increment (++) and decrement 
(--) operators:

let count = 5;
count++;  // Increment
console.log(count);  // Outputs: 6
count--;  // Decrement
console.log(count);  // Outputs: 5

The Math Object
JavaScript provides a built-in Math object that 
contains properties and methods for mathematical 
constants and functions.

Mathematical Constants
The Math object includes several mathematical constants:

console.log(Math.PI);    // pi (≈3.14159)
console.log(Math.E);     // Euler's number (≈2.71828)
console.log(Math.SQRT2); // Square root of 2 (≈1.41421)


Common Math Methods
Math.abs(): 
Returns the absolute value of a number.

console.log(Math.abs(-5));  // Outputs: 5

Math.round(), Math.ceil(), Math.floor(): Different ways 
of rounding numbers.

console.log(Math.round(4.7));  // Outputs: 5
console.log(Math.ceil(4.2));   // Outputs: 5
console.log(Math.floor(4.8));  // Outputs: 4

Math.max() and Math.min(): 
Return the largest and smallest values respectively.

console.log(Math.max(1, 3, 2));  // Outputs: 3
console.log(Math.min(1, 3, 2));  // Outputs: 1

Math.pow(): 
Returns the base to the exponent power.

console.log(Math.pow(2, 3));  // Outputs: 8 (2^3)

Math.sqrt(): 
Returns the square root of a number.

console.log(Math.sqrt(16));  // Outputs: 4

Math.random(): 
Returns a pseudo-random number between 0 and 1.

console.log(Math.random());  // Outputs: a random 
number between 0 and 1

Handling Precision and Rounding Errors
As mentioned earlier, JavaScript's use of floating-point 
numbers can lead to precision errors in certain 
calculations. This is particularly noticeable with decimal 
arithmetic.

Example of precision error:
console.log(0.1 + 0.2);  // Outputs: 0.30000000000000004

To handle these errors, you can use techniques like rounding 
to a fixed number of decimal places:

let result = (0.1 + 0.2).toFixed(2);
console.log(result);  // Outputs: "0.30"

Note that toFixed() returns a string, so you might need 
to convert it back to a number:

let numericResult = Number((0.1 + 0.2).toFixed(2));
console.log(numericResult);  // Outputs: 0.3

Working with BigInt
For cases where you need to work with integers larger 
than 2^53 - 1, JavaScript provides the BigInt type 
(introduced in ES2020).

let bigNumber = 1234567890123456789012345678901234567890n;
console.log(typeof bigNumber);  // Outputs: "bigint"

Note that you can't mix BigInt and regular numbers in 
operations:

let result = 1n + 2;  // Throws a TypeError

You need to convert one type to the other:

let result = 1n + BigInt(2);
console.log(result);  // Outputs: 3n

Understanding how JavaScript handles numbers and math 
operations is crucial for accurate calculations in your 
programs. Always be aware of potential precision issues 
when working with floating-point arithmetic, and use 
appropriate techniques to handle them when necessary.


5. Dates and Times

Introduction to the Date Object
JavaScript provides a built-in Date object to work with 
dates and times. The Date object allows you to create, 
manipulate, and format dates, as well as perform time-based 
calculations.

Creating Date Objects
There are several ways to create a Date object:

Current date and time:

let now = new Date();
console.log(now);  // Outputs the current date and time

Specific date and time:

let specificDate = new Date(2023, 0, 15, 10, 30, 0);
console.log(specificDate);  // Outputs: Sun Jan 15 2023 10:30:00

Note: Months are zero-indexed (0-11), where 0 represents January.

From a date string:

let dateFromString = new Date("2023-01-15T10:30:00");
console.log(dateFromString);  // Outputs: Sun Jan 15 2023 10:30:00

From timestamp (milliseconds since January 1, 1970):

let dateFromTimestamp = new Date(1673778600000);
console.log(dateFromTimestamp);  
// Outputs: Sun Jan 15 2023 10:30:00

Getting Date Components
The Date object provides several methods to extract individual 
components of a date:

let date = new Date(2023, 0, 15, 10, 30, 0);

console.log(date.getFullYear());     // 2023
console.log(date.getMonth());        // 0 (January)
console.log(date.getDate());         // 15
console.log(date.getDay());          // 0 (Sunday)
console.log(date.getHours());        // 10
console.log(date.getMinutes());      // 30
console.log(date.getSeconds());      // 0
console.log(date.getMilliseconds()); // 0

Note: 
getDay() returns the day of the week (0-6), where 0 represents 
Sunday.

Setting Date Components

Similarly, you can set individual components of a date:

let date = new Date(2023, 0, 15);

date.setFullYear(2024);
date.setMonth(6);  // July
date.setDate(20);
date.setHours(15);
date.setMinutes(45);
date.setSeconds(30);

console.log(date);  // Outputs: Sat Jul 20 2024 15:45:30

Formatting Dates
JavaScript doesn't have built-in extensive date formatting 
options, but you can create custom formats using the available 
methods:

function formatDate(date) {
    let day = date.getDate().toString().padStart(2, '0');
    let month = (date.getMonth() + 1).toString().padStart(2, '0');
    let year = date.getFullYear();
    return `${day}/${month}/${year}`;
}

let date = new Date(2023, 0, 15);
console.log(formatDate(date));  // Outputs: 15/01/2023

For more advanced formatting, you can use the Intl.DateTimeFormat 
object:

let date = new Date(2023, 0, 15);
let formatter = new Intl.DateTimeFormat('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
});

console.log(formatter.format(date));  // Outputs: January 15, 2023

Performing Date Calculations
You can perform various calculations with dates:

Adding or subtracting days:

let date = new Date(2023, 0, 15);
date.setDate(date.getDate() + 7);
console.log(date);  // Outputs: Sun Jan 22 2023

Calculating the difference between dates:

let date1 = new Date(2023, 0, 1);
let date2 = new Date(2023, 11, 31);
let difference = date2 - date1;
let days = Math.floor(difference / (1000 * 60 * 60 * 24));
console.log(`There are ${days} days between the dates`);  
// Outputs: There are 364 days between the dates

Working with Timestamps
Timestamps represent the number of milliseconds since 
January 1, 1970 (Unix Epoch). They're useful for storing 
dates in a numeric format and for date calculations.

let now = new Date();
let timestamp = now.getTime();
console.log(timestamp);  // Outputs: current timestamp

// Creating a date from a timestamp
let dateFromTimestamp = new Date(timestamp);
console.log(dateFromTimestamp);  // Outputs: current date 
and time

Handling Time Zones
By default, JavaScript works with dates in the local time 
zone of the system it's running on. However, you can work 
with UTC (Coordinated Universal Time) using specific 
methods:

let date = new Date();
console.log(date.getUTCHours());  // Hours in UTC
console.log(date.getHours());     // Hours in local time zone

// Getting the time zone offset in minutes
console.log(date.getTimezoneOffset());

Best Practices and Common Pitfalls
Always consider time zones: Be aware that dates may be 
interpreted differently depending on the user's time zone.

Use UTC for storing dates: When storing dates, especially 
for future events, consider using UTC to avoid time zone 
issues.

Be cautious with date parsing: 
Parsing date strings can be unpredictable across different 
browsers. It's often safer to manually parse date strings 
or use a library.

Consider using a date library: 
For complex date operations or consistent cross-browser 
behavior, consider using a library like Moment.js or 
date-fns.

Working with dates and times is a common task in many 
applications. Understanding these concepts will help 
you handle various date-related operations effectively 
in your JavaScript programs.


C. JS in the Browser
====================

1. The Document Object Model (DOM)

Understanding the DOM Tree
The Document Object Model (DOM) is a crucial concept in web 
development, serving as the bridge between web pages and 
programming languages like JavaScript. It's not just a simple 
concept, but a complex, hierarchical structure that represents 
every element on a web page.

What is the DOM?
The DOM is an object-oriented representation of a web document. 
It's not part of JavaScript itself, but rather a Web API that 
browsers implement. The DOM represents an HTML or XML document 
as a tree-like structure where each node is an object 
representing a part of the document.

Key points to understand:
The DOM is language-agnostic, meaning it can be used with various 
programming languages, not just JavaScript.

It provides a structured representation of the document, allowing 
programs to read and manipulate the document's content, structure, 
and styles.

The DOM is live, meaning that when it's modified, the page's 
display updates to reflect the changes.

DOM Tree Structure
Let's break down a simple HTML document into its DOM representation:

<!DOCTYPE html>
<html>
<head>
    <title>My Web Page</title>
</head>

<body>
    <h1>Welcome</h1>
    <p>This is a paragraph.</p>
</body>
</html>


The corresponding DOM tree would look like this:
Document
└── DOCTYPE: html
└── HTML
    ├── HEAD
    │   └── TITLE
    │       └── Text: "My Web Page"
    └── BODY
        ├── H1
        │   └── Text: "Welcome"
        └── P
            └── Text: "This is a paragraph."

Each box in this tree is a node in the DOM. There are 
several types of nodes:

Document node: 
The root of the tree, representing the entire document.

Element nodes: 
Represent HTML elements.

Attribute nodes: 
Represent attributes of elements.

Text nodes: 
Represent text within elements.

Comment nodes: 
Represent HTML comments.

Understanding this structure is crucial because it forms 
the basis of how we select and manipulate elements using 
JavaScript.

Selecting DOM Elements
Before we can manipulate elements, we need to select them. 
JavaScript provides several methods to do this, each with 
its own use cases.

Selecting Elements by ID
The getElementById() method is the fastest way to select 
a single element:

const headingElement = document.getElementById('main-heading');

This selects the element with id="main-heading". Remember, 
IDs should be unique within a document.

Selecting Elements by Class Name
To select elements by their class, use getElementsByClassName():

const paragraphs = document.getElementsByClassName('content-paragraph');

This returns a live HTMLCollection of all elements with the 
class 'content-paragraph'.

Selecting Elements by Tag Name
getElementsByTagName() selects all elements of a specified tag:

const allDivs = document.getElementsByTagName('div');

Using CSS Selectors
The most flexible methods are querySelector() and querySelectorAll(). 
These allow you to use any valid CSS selector:

// Select the first .button element inside #menu
const firstButton = document.querySelector('#menu .button');

// Select all .item elements
const allItems = document.querySelectorAll('.item');

querySelector() returns the first matching element, while 
querySelectorAll() returns a NodeList of all matching 
elements.

Manipulating DOM Elements
Once we've selected elements, we can manipulate them in various 
ways.

Changing Text Content
To change the text of an element:

const heading = document.querySelector('h1');
heading.textContent = 'New Heading Text';

textContent is preferred over innerText as it's faster and 
doesn't trigger a reflow.

Changing HTML Content
To change the HTML inside an element:

const paragraph = document.querySelector('p');
paragraph.innerHTML = 'This is <strong>bold</strong> text.';

Be cautious with innerHTML as it can pose security risks if 
used with user-input data.

Changing Attributes

Attributes can be get, set, or removed:

const link = document.querySelector('a');

// Get attribute
console.log(link.getAttribute('href'));

// Set attribute
link.setAttribute('href', 'https://example.com');

// Remove attribute
link.removeAttribute('target');

Changing Styles
Inline styles can be manipulated via the style property:

const div = document.querySelector('div');
div.style.backgroundColor = 'blue';
div.style.padding = '10px';

For more complex style changes, it's often better to add 
or remove classes:

div.classList.add('highlight');
div.classList.remove('hidden');
div.classList.toggle('active');

Creating and Removing DOM Elements

Creating Elements
To create a new element:

const newParagraph = document.createElement('p');
newParagraph.textContent = 'This is a new paragraph.';

Adding Elements to the DOM
To add the new element to the document:

document.body.appendChild(newParagraph);

You can also insert at a specific position:

const referenceElement = document.querySelector('#existing-element');
document.body.insertBefore(newParagraph, referenceElement);

Removing Elements
To remove an element:

const elementToRemove = document.querySelector('#remove-me');
elementToRemove.parentNode.removeChild(elementToRemove);

Or using the more modern remove() method:

elementToRemove.remove();

Practical Exercise: Dynamic To-Do List

Let's create a more complex to-do list application that 
demonstrates various DOM manipulation techniques:

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic To-Do List</title>
    <style>
        .completed { text-decoration: line-through; color: gray; }
    </style>
</head>

<body>
    <h1>My To-Do List</h1>
    <input type="text" id="todoInput" placeholder="Enter a new task">
    <button id="addButton">Add Task</button>
    <ul id="todoList"></ul>

    <script>
        const todoInput = document.getElementById('todoInput');
        const addButton = document.getElementById('addButton');
        const todoList = document.getElementById('todoList');

        addButton.addEventListener('click', addTask);

        function addTask() {
            if (todoInput.value.trim() === '') return;

            const li = document.createElement('li');
            li.textContent = todoInput.value;

            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';
            deleteButton.addEventListener('click', () => li.remove());

            const completeButton = document.createElement('button');
            completeButton.textContent = 'Complete';
            completeButton.addEventListener('click', () => li.classList.toggle('completed'));

            li.appendChild(deleteButton);
            li.appendChild(completeButton);
            todoList.appendChild(li);

            todoInput.value = '';
        }
    </script>
</body>
</html>


This example demonstrates:
Creating elements (createElement)

Adding elements to the DOM (appendChild)

Handling events (addEventListener)

Manipulating classes (classList.toggle)

Removing elements (remove)

Advanced DOM Concepts

DOM Traversal
The DOM allows for easy traversal between nodes:

const parent = element.parentNode;
const nextSibling = element.nextSibling;
const previousSibling = element.previousSibling;
const children = element.childNodes;

Performance Considerations
DOM manipulation can be expensive. For better performance:

Minimize DOM access and updates

Use document fragments for batch insertions

Consider using requestAnimationFrame for visual updates

Event Delegation
Instead of attaching events to individual elements, you can 
attach a single event listener to a parent element:

todoList.addEventListener('click', function(e) {
    if (e.target.tagName === 'BUTTON') {
        if (e.target.textContent === 'Delete') {
            e.target.parentNode.remove();
        } else if (e.target.textContent === 'Complete') {
            e.target.parentNode.classList.toggle('completed');
        }
    }
});

This technique is more efficient and works for dynamically 
added elements.

Conclusion
The DOM is a powerful interface that allows JavaScript to 
interact with web pages. Understanding how to navigate, 
manipulate, and create DOM elements is crucial for creating 
dynamic and interactive web applications. As you progress, 
you'll discover more advanced techniques and best practices 
for working with the DOM efficiently.


2. Events in JavaScript
Events are a fundamental part of JavaScript programming, 
especially when it comes to creating interactive web 
applications. They allow us to respond to user actions 
and system occurrences, making our web pages dynamic and 
responsive.

Understanding Event-Driven Programming
In event-driven programming, the flow of the program is 
determined by events such as user actions, sensor outputs, 
or messages from other programs. In the context of web 
development, these events are typically user interactions 
like clicks, key presses, or mouse movements.

JavaScript uses an event-driven programming model. Instead 
of executing code in a strictly linear fashion, JavaScript 
waits for events to occur and then executes designated 
functions (called event handlers or event listeners) in 
response to those events.

Common Types of Events
JavaScript can handle a wide variety of events. Here are 
some of the most common:

Mouse events: 
click, dblclick, mousedown, mouseup, mousemove, mouseover, 
mouseout

Keyboard events: 
keydown, keyup, keypress

Form events: 
submit, change, focus, blur

Window events: 
load, resize, scroll, unload

Adding Event Listeners
To respond to an event, we need to attach an event listener 
to the relevant DOM element. The addEventListener method is 
the modern way to handle events in JavaScript. Here's its 
basic syntax:

element.addEventListener(eventType, eventHandler, useCapture);

eventType: 
A string that specifies the event type (e.g., 'click', 'keydown')

eventHandler: 
The function to be executed when the event occurs

useCapture: 
An optional boolean parameter for advanced event handling 
(default is false)

Let's look at a simple example:

const button = document.querySelector('#myButton');

function handleClick() {
    console.log('Button clicked!');
}

button.addEventListener('click', handleClick);

In this example, we're attaching a 'click' event listener 
to a button. When the button is clicked, it will log 
"Button clicked!" to the console.

The Event Object
When an event occurs, JavaScript automatically passes an 
event object to the event handler function. This object 
contains useful information about the event. Let's modify 
our previous example to use the event object:

function handleClick(event) {
    console.log('Button clicked!');

    console.log('Event type:', event.type);
    console.log('Target element:', event.target);
}

button.addEventListener('click', handleClick);

The event object provides properties like:
type: 
The type of event (e.g., 'click', 'keydown')

target: 
The element that triggered the event

clientX/clientY: 
The mouse position for mouse events

key: 
The key pressed for keyboard events

Removing Event Listeners
Sometimes, you might want to stop listening for an event. 
You can do this with the removeEventListener method:

button.removeEventListener('click', handleClick);

Note that to remove a listener, you need to specify the 
same function that was originally added. This is why it's 
often better to use named functions instead of anonymous 
functions when adding event listeners.

Event Bubbling and Capturing

When an event happens on an element, it first runs the 
handlers on it, then on its parent, then all the way up 
on other ancestors. This process is called "bubbling", 
because events "bubble" from the inner element up through 
parents like a bubble in water.

Here's an example to demonstrate bubbling:

<div id="outer">
    <div id="inner">
        <button id="button">Click me</button>
    </div>
</div>

<script>
    document
        .getElementById('outer')
        .addEventListener('click', 
            () => console.log('Outer div clicked')
        );

    document
        .getElementById('inner')
        .addEventListener('click', 
            () => console.log('Inner div clicked')
        );

    document
        .getElementById('button')
        .addEventListener('click', 
            () => console.log('Button clicked')
        );
</script>

If you click the button, you'll see three messages in 
the console:

"Button clicked"

"Inner div clicked"

"Outer div clicked"

This is bubbling in action. The event starts at the button, 
then bubbles up to its parent elements.

The opposite of bubbling is capturing. It's rarely used, but 
for completeness, you should know that events actually travel 
in three phases:

Capturing phase – the event goes down to the element

Target phase – the event reaches the target element

Bubbling phase – the event bubbles up from the element

You can use the third parameter of addEventListener to catch 
events on the capturing phase:

element.addEventListener('click', handler, true);

Preventing Default Behavior
Some events have default behaviors. For example, when you 
click on a link, it will navigate to the URL. Sometimes 
you want to prevent this default behavior. You can do this 
with the preventDefault() method of the event object:

document.querySelector('a').addEventListener('click', function(event) {
    event.preventDefault();

    console.log('Link clicked, but page navigation prevented');
});

Practical Exercise: Interactive Image Gallery

Let's create a simple image gallery to practice working 
with events:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Image Gallery</title>

    <style>
        .thumbnail { width: 100px; height: 100px; object-fit: cover; margin: 5px; cursor: pointer; }
        #featured { width: 500px; height: 500px; object-fit: cover; }
    </style>
</head>

<body>
    <div id="gallery">
        <img src="https://picsum.photos/id/1/500/500" alt="Featured Image" id="featured">
       
        <div id="thumbnails">
            <img src="https://picsum.photos/id/1/100/100" alt="Thumbnail 1" class="thumbnail">
            <img src="https://picsum.photos/id/2/100/100" alt="Thumbnail 2" class="thumbnail">
            <img src="https://picsum.photos/id/3/100/100" alt="Thumbnail 3" class="thumbnail">
            <img src="https://picsum.photos/id/4/100/100" alt="Thumbnail 4" class="thumbnail">
        </div>
    </div>

    <script>
        const featured = document.getElementById('featured');
        const thumbnails = document.getElementById('thumbnails');

        thumbnails.addEventListener('click', function(event) {
            if (event.target.classList.contains('thumbnail')) {
                featured.src = event.target.src.replace('100/100', '500/500');
            }
        });

        featured.addEventListener('mouseenter', function() {
            this.style.opacity = '0.7';
        });

        featured.addEventListener('mouseleave', function() {
            this.style.opacity = '1';
        });
    </script>
</body>
</html>

This example demonstrates:
Event delegation (clicking on thumbnails)

Mouse events (mouseenter and mouseleave)

Manipulating styles based on events

Preventing the need for multiple event listeners by using 
event delegation

Events are a powerful feature of JavaScript that allow you 
to create truly interactive web applications. As you 
continue to develop your skills, you'll find countless ways 
to use events to enhance user experiences and create dynamic, 
responsive interfaces.


3. Forms and Input Handling
Forms are a crucial part of web applications, enabling users 
to input and submit data. JavaScript provides various methods 
and techniques to handle forms, validate user input, and 
enhance the overall user experience.

Capturing and Validating Form Data
When users interact with a form, the data they input must be 
captured, processed, and often validated before submission. 
JavaScript plays a key role in these tasks, ensuring that 
the data is correct and complete before being sent to the 
server.

Accessing Form Elements
JavaScript allows you to access form elements using various 
methods:

document.forms: 
Accesses all forms on a page.

document.getElementById(): 
Retrieves a specific form element by its ID.

form.elements[]: 
Accesses elements within a specific form by name or index.

For example:

let form = document.forms['myForm'];
let nameInput = form.elements['name'];
let emailInput = document.getElementById('email');

Handling Form Submissions
To handle form submissions, you can attach an event listener 
to the form's submit event. This allows you to intercept the 
submission, validate the data, and either allow the 
submission to proceed or prevent it.

Example:

form.addEventListener('submit', function(event) {
    // Prevents the default form submission behavior
    event.preventDefault(); 

    let name = nameInput.value.trim();
    let email = emailInput.value.trim();

    if (validateForm(name, email)) {
        // Proceed with form submission (e.g., via AJAX)
    } else {
        alert('Please fill out the form correctly.');
    }
});

Validating Input Fields
JavaScript provides several ways to validate input fields 
before submission:

Required Fields: 
Ensure that fields are not left empty.

Pattern Matching: 
Validate data formats (e.g., email, phone numbers) using 
regular expressions.

Length Checks: 
Ensure the input meets minimum or maximum length requirements.

Example:

function validateForm(name, email) {
    if (name === '' || email === '') {
        return false;
    }

    // Basic email validation
    let emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

    if (!emailPattern.test(email)) {
        return false;
    }

    return true;
}

Handling User Input with JavaScript
Handling user input effectively is essential for creating 
responsive and user-friendly forms. JavaScript can respond 
to user actions, such as typing, selecting options, and 
more, to provide immediate feedback or manipulate data.

Real-Time Input Validation
You can validate user input in real-time as they type 
or select options. This approach improves user experience 
by providing immediate feedback and guiding users to 
correct any errors.

Example:

emailInput.addEventListener('input', function() {
    let isValid = emailPattern.test(this.value);
    this.style.borderColor = isValid ? 'green' : 'red';
});

Handling Different Input Types
JavaScript allows you to handle various input types, such 
as text, checkboxes, radio buttons, and more. Each input 
type has specific properties and methods that can be used 
to capture and process data.

Example:

let gender = document.querySelector('input[name="gender"]:checked').value;
let interests = Array.from(document.querySelectorAll('input[name="interests"]:checked')).map(el => el.value);

console.log('Gender:', gender);
console.log('Interests:', interests.join(', '));

Preventing Default Form Behaviors
Sometimes, you may want to prevent the default behavior 
of forms, such as submitting or navigating away from the 
current page. JavaScript allows you to control these 
behaviors to provide a more customized user experience.

Preventing Form Submission
You can prevent form submission using 
event.preventDefault() within a submit event handler. 
This is useful for forms that require client-side 
validation or need to submit data via AJAX.

Example:

form.addEventListener('submit', function(event) {
    event.preventDefault(); // Prevents the default submission

    // Custom form handling logic
    submitFormData();
});

Preventing Default Input Actions
For other input elements, such as links or buttons, you 
can also prevent default actions like navigation or form 
resets.

Example:

document.querySelector('a').addEventListener('click', function(event) {
    event.preventDefault(); // Prevents link navigation

    alert('Link was clicked but default navigation was prevented.');
});

Practical Exercise: Simple Registration Form
Let’s apply what we’ve learned by creating a simple 
registration form with validation and JavaScript-based 
handling.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Registration Form</title>

    <style>
        .error { color: red; }
        .valid { color: green; }
    </style>
</head>

<body>
    <form id="registrationForm">
        <label for="name">Name:</label>
        <input type="text" id="name" name="name">
        <span id="nameError" class="error"></span>
        <br><br>

        <label for="email">Email:</label>
        <input type="email" id="email" name="email">
        <span id="emailError" class="error"></span>
        <br><br>

        <label for="password">Password:</label>
        <input type="password" id="password" name="password">
        <span id="passwordError" class="error"></span>
        <br><br>

        <button type="submit">Register</button>
    </form>

    <script>
        const form = document.getElementById('registrationForm');
        const nameInput = document.getElementById('name');
        const emailInput = document.getElementById('email');
        const passwordInput = document.getElementById('password');

        const nameError = document.getElementById('nameError');
        const emailError = document.getElementById('emailError');
        const passwordError = document.getElementById('passwordError');

        form.addEventListener('submit', function(event) {
            event.preventDefault(); // Prevent form submission

            // Clear previous errors
            nameError.textContent = '';
            emailError.textContent = '';
            passwordError.textContent = '';

            // Validate fields
            let isValid = true;

            if (nameInput.value.trim() === '') {
                nameError.textContent = 'Name is required.';
                isValid = false;
            }

            if (emailInput.value.trim() === '' || !emailInput.value.includes('@')) {
                emailError.textContent = 'Valid email is required.';
                isValid = false;
            }

            if (passwordInput.value.trim().length < 6) {
                passwordError.textContent = 'Password must be at least 6 characters long.';
                isValid = false;
            }

            if (isValid) {
                alert('Registration successful!');
                form.reset(); // Reset form fields
            }
        });
    </script>
</body>
</html>

Summary
Handling forms and input in JavaScript is a vital skill 
for any web developer. By effectively capturing, 
validating, and managing user input, you can create more 
interactive, user-friendly, and secure web applications. 
As you practice, you'll discover even more ways to harness 
the power of JavaScript to improve your forms and user 
interaction


4. Working with Browser Storage
In modern web applications, storing data locally in the 
user's browser can significantly enhance the user 
experience by enabling persistent data storage across 
sessions. JavaScript provides various methods for 
client-side storage, including localStorage, sessionStorage, 
and cookies.

Introduction to Local Storage and Session Storage
Local storage and session storage are part of the Web 
Storage API, allowing developers to store key-value pairs 
directly in the browser.

Local Storage
localStorage is used to store data with no expiration time. 
The data persists even after the browser is closed and 
reopened. This is useful for storing data that should be 
available across sessions, such as user preferences or 
settings.

Example:

// Setting an item in local storage
localStorage.setItem('username', 'JohnDoe');

// Retrieving an item from local storage
let username = localStorage.getItem('username');
console.log(username); // Output: JohnDoe

// Removing an item from local storage
localStorage.removeItem('username');

// Clearing all items in local storage
localStorage.clear();

Session Storage
sessionStorage is similar to localStorage, but it only 
persists data for the duration of the page session. 
Once the browser tab is closed, the data is lost. This 
is ideal for storing temporary data like form inputs 
during a session.

Example:

// Setting an item in session storage
sessionStorage.setItem('sessionID', 'abc123');

// Retrieving an item from session storage
let sessionID = sessionStorage.getItem('sessionID');
console.log(sessionID); // Output: abc123

// Removing an item from session storage
sessionStorage.removeItem('sessionID');

// Clearing all items in session storage
sessionStorage.clear();

Storing and Retrieving Data in the Browser
Storing and retrieving data in localStorage and 
sessionStorage is straightforward. The data is stored 
as strings, so if you're storing complex data types 
like arrays or objects, you'll need to convert them 
to strings using JSON.stringify() and convert them 
back using JSON.parse().

Example:

// Storing an object in localStorage
let user = { name: 'John', age: 30 };
localStorage.setItem('user', JSON.stringify(user));

// Retrieving and parsing the object from localStorage
let storedUser = JSON.parse(localStorage.getItem('user'));
console.log(storedUser.name); // Output: John

Similarly, you can store arrays, nested objects, or any 
other serializable data structures.

Understanding Cookies and Their Usage in JavaScript
Cookies are another way to store data in the browser. 
They have been around longer than the Web Storage API 
and are often used for tracking, authentication, and 
storing small amounts of data.

Setting and Retrieving Cookies
Cookies are managed using the document.cookie property. 
Unlike localStorage and sessionStorage, cookies are 
automatically sent to the server with every HTTP request.

Example:

// Setting a cookie
document.cookie = "username=JohnDoe; expires=Fri, 
31 Dec 2024 12:00:00 UTC; path=/";

// Retrieving cookies
let cookies = document.cookie;
console.log(cookies); // Output: username=JohnDoe

// Function to get a specific cookie by name
function getCookie(name) {
    let matches = document.cookie.match(new RegExp(
        "(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"
    ));

    return matches ? decodeURIComponent(matches[1]) : undefined;
}

console.log(getCookie('username')); // Output: JohnDoe

Cookie Attributes
expires: 
Sets an expiration date for the cookie.

path: 
Defines the path where the cookie is accessible.

domain: 
Specifies the domain that can access the cookie.

secure: 
Ensures the cookie is sent only over HTTPS.

httpOnly: 
Restricts access to the cookie via JavaScript, enhancing 
security.

Example:

// Setting a secure cookie that can only be sent over HTTPS
document.cookie = "token=abc123; secure; httpOnly; path=/";

Practical Exercise: User Preferences with Local Storage

Let’s create a simple example where user preferences 
(like theme selection) are stored in localStorage.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>User Preferences</title>

    <style>
        body.light-theme { background-color: white; color: black; }
        body.dark-theme { background-color: black; color: white; }
    </style>
</head>

<body>
    <h1>Choose Your Theme</h1>
    <button id="lightTheme">Light Theme</button>
    <button id="darkTheme">Dark Theme</button>

    <script>
        const lightThemeButton = document.getElementById('lightTheme');
        const darkThemeButton = document.getElementById('darkTheme');

        // Apply stored theme on page load
        const savedTheme = localStorage.getItem('theme');

        if (savedTheme) {
            document.body.className = savedTheme;
        }

        // Event listeners for theme buttons
        lightThemeButton.addEventListener('click', () => {
            document.body.className = 'light-theme';
            localStorage.setItem('theme', 'light-theme');
        });

        darkThemeButton.addEventListener('click', () => {
            document.body.className = 'dark-theme';
            localStorage.setItem('theme', 'dark-theme');
        });
    </script>
</body>
</html>

In this example:
The user can select a light or dark theme.

The selected theme is stored in localStorage so that it 
persists across sessions.

When the page is reloaded, the stored theme is automatically 
applied.

Summary
Browser storage is a powerful tool for creating more dynamic 
and persistent user experiences. Whether you need to store 
data temporarily during a session or across multiple sessions, 
localStorage, sessionStorage, and cookies offer versatile 
solutions. Understanding how to effectively use these tools 
will allow you to build more sophisticated and user-friendly 
web applications.


5. Asynchronous JavaScript

Asynchronous programming is a fundamental concept in JavaScript 
that allows you to perform tasks in the background without 
blocking the main thread. This is especially useful when 
handling tasks like fetching data from a server, reading files, 
or performing complex calculations. JavaScript provides several 
ways to work with asynchronous operations, including callbacks, 
promises, and the async/await syntax.

Introduction to Callbacks
A callback is a function that is passed as an argument to another 
function and is executed after some operation has been completed. 
Callbacks are one of the earliest methods of handling asynchronous 
operations in JavaScript.

Basic Callback Example
Here’s a simple example to illustrate how callbacks work:

function fetchData(callback) {
    setTimeout(() => {
        let data = { id: 1, name: 'John Doe' };

        callback(data);
    }, 2000); // Simulating a 2-second delay
}

function displayData(data) {
    console.log('Data received:', data);
}

fetchData(displayData);

In this example:
fetchData simulates an asynchronous operation (e.g., fetching 
data from a server) using setTimeout.

The displayData function is passed as a callback and is called 
when the data is ready.

Callback Hell
While callbacks are simple and effective, they can lead to 
what’s known as "callback hell" when dealing with multiple 
asynchronous operations, resulting in deeply nested and 
hard-to-maintain code.

Example:

fetchData1((data1) => {
    fetchData2(data1, (data2) => {

        fetchData3(data2, (data3) => {

            console.log('Final data:', data3);

        });

    });
});

Introduction to Promises
Promises are a more powerful way to handle asynchronous operations 
in JavaScript. A promise represents the eventual completion (or 
failure) of an asynchronous operation and its resulting value.

Creating a Promise
A promise can be created using the Promise constructor, which 
takes a function (called the executor) that receives two arguments: 
resolve and reject.

Example:

let myPromise = new Promise((resolve, reject) => {
    let success = true;

    if (success) {
        resolve('Operation successful!');
    } else {
        reject('Operation failed.');
    }
});

myPromise
    .then((message) => {
        console.log(message); // Output: Operation successful!
    })
    .catch((error) => {
        console.log(error);
    });

In this example:
If the operation is successful, resolve is called, and the 
promise is fulfilled.

If the operation fails, reject is called, and the promise is 
rejected.

then() is used to handle a fulfilled promise, and catch() handles a 
rejected promise.

Chaining Promises
One of the main advantages of promises is that they can be chained, 
making it easier to handle sequential asynchronous operations.

Example:

fetchData1()
    .then((data1) => fetchData2(data1))

    .then((data2) => fetchData3(data2))

    .then((data3) => {
        console.log('Final data:', data3);
    })
    .catch((error) => {
        console.error('Error:', error);
    });

Using async/await
The async/await syntax is a more recent addition to JavaScript 
that simplifies working with promises. It allows you to write 
asynchronous code that looks and behaves more like synchronous 
code, making it easier to read and maintain.

Creating an Async Function
An async function is a function declared with the async keyword. 
Inside an async function, you can use the await keyword to pause 
the execution of the function until a promise is resolved.

Example:

async function fetchData() {
    let response = await fetch('https://api.example.com/data');

    let data = await response.json();

    console.log('Data:', data);
}

fetchData();

In this example:
fetchData is an async function that fetches data from an API.

await is used to wait for the fetch promise to resolve before continuing.

The code is easier to understand compared to using promise chaining.

Error Handling with try/catch
You can handle errors in an async function using try/catch blocks.

Example:

async function fetchData() {
    try {
        let response = await fetch('https://api.example.com/data');

        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        let data = await response.json();

        console.log('Data:', data);
    } catch (error) {
        console.error('Error fetching data:', error);
    }
}

fetchData();

In this example:
try/catch is used to handle errors that may occur during the 
asynchronous operation.

Making HTTP Requests with the Fetch API
The Fetch API is a modern way to make HTTP requests in JavaScript. 
It returns a promise that resolves to the Response object 
representing the response to the request.

Basic Fetch Example
Here’s how you can use the Fetch API to make a GET request:

fetch('https://api.example.com/data')
    .then((response) => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        return response.json();
    })
    .then((data) => {
        console.log('Data:', data);
    })
    .catch((error) => {
        console.error('Error:', error);
    });

Using Fetch with async/await
The Fetch API works seamlessly with async/await syntax:

async function fetchData() {
    try {
        let response = await fetch('https://api.example.com/data');

        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        let data = await response.json();

        console.log('Data:', data);
    } catch (error) {
        console.error('Error:', error);
    }
}

fetchData();

Handling Asynchronous Operations and Errors
Effective error handling is crucial when working with asynchronous 
operations to ensure your application behaves correctly under 
different conditions.

Handling Multiple Promises with Promise.all
Promise.all allows you to execute multiple promises in parallel 
and wait for all of them to resolve.

Example:

let promise1 = fetch('https://api.example.com/data1');
let promise2 = fetch('https://api.example.com/data2');

Promise.all([promise1, promise2])
    .then((responses) => {
        return Promise.all(responses.map((response) => response.json()));
    })
    .then((data) => {
        console.log('Data from both APIs:', data);
    })
    .catch((error) => {
        console.error('Error fetching data:', error);
    });

Handling Promises Independently with Promise.race
Promise.race returns a promise that resolves or rejects as soon 
as one of the promises in the array resolves or rejects.

Example:

let promise1 = new Promise((resolve) => setTimeout(resolve, 100, 'First'));
let promise2 = new Promise((resolve) => setTimeout(resolve, 200, 'Second'));

Promise.race([promise1, promise2])
    .then((value) => {
        console.log('Race won by:', value);
    });

Practical Exercise: 
Fetching and Displaying Data from an API

Let’s create a simple example that fetches data from an API 
and displays it on a webpage.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Data Fetch</title>
</head>

<body>
    <h1>User Data</h1>
    <ul id="userList"></ul>

    <script>
        async function fetchUserData() {
            try {
                let response = await fetch('https://jsonplaceholder.typicode.com/users');

                if (!response.ok) {
                    throw new Error('Failed to fetch data');
                }

                let users = await response.json();

                displayUsers(users);
            } catch (error) {
                console.error('Error:', error);
            }
        }

        function displayUsers(users) {
            const userList = document.getElementById('userList');

            users.forEach(user => {
                let listItem = document.createElement('li');

                listItem.textContent = `${user.name} (${user.email})`;

                userList.appendChild(listItem);
            });
        }

        fetchUserData();
    </script>
</body>
</html>

In this example:
The fetchUserData function asynchronously fetches user data from 
an API.

The fetched data is displayed as a list on the webpage.

Summary
Asynchronous programming in JavaScript is essential for creating 
smooth and responsive web applications. Understanding callbacks, 
promises, and async/await is crucial for effectively managing 
asynchronous operations and handling errors. With these tools, 
you can write cleaner, more efficient, and easier-to-maintain 
code while providing a better user experience.


D. Advanced JS Concepts
=======================

1. Object Oriented JavaScript

Object-oriented programming (OOP) is a paradigm that uses objects to design and organize software. In JavaScript, OOP is supported through prototypes and classes, allowing you to create and manage complex data structures and behaviors. Understanding OOP concepts in JavaScript enables you to write more modular, reusable, and maintainable code.

Introduction to Prototypes and Inheritance

JavaScript is a prototype-based language, which means that objects can inherit properties and methods from other objects. This inheritance mechanism is a key part of JavaScript's OOP capabilities.

What is a Prototype?

In JavaScript, every object has a prototype, which is another object that it inherits properties and methods from. This prototype chain allows objects to share functionality.

Example:

let animal = {
    eats: true,
    sleep() {
        console.log("The animal is sleeping.");
    }
};

let dog = {
    barks: true
};

// Set animal as the prototype of dog
dog.__proto__ = animal;

console.log(dog.eats); // Output: true (inherited from animal)
dog.sleep(); // Output: The animal is sleeping. (inherited from animal)


In this example:





dog inherits properties and methods from animal through the prototype chain.

Prototype Chain

The prototype chain is a series of links between objects. When you access a property or method on an object, JavaScript will first look for that property on the object itself. If it doesn't find it, it will continue to search up the prototype chain until it either finds the property or reaches the end of the chain (usually Object.prototype).

Creating and Using Constructor Functions

Before ES6 introduced classes, constructor functions were the primary way to create objects in an OOP manner.

Defining a Constructor Function

A constructor function is a special type of function that is used to create instances of objects. By convention, constructor functions start with an uppercase letter.

Example:

function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    console.log(`Hello, my name is ${this.name}.`);
};

let john = new Person('John', 30);
let jane = new Person('Jane', 25);

john.greet(); // Output: Hello, my name is John.
jane.greet(); // Output: Hello, my name is Jane.


In this example:





Person is a constructor function.



The new keyword is used to create instances of Person.



Methods can be added to the Person.prototype so that all instances share the same method.

Inheritance with Constructor Functions

You can implement inheritance with constructor functions by setting the prototype of the child constructor to an instance of the parent constructor.

Example:

function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function() {
    console.log(`${this.name} makes a sound.`);
};

function Dog(name, breed) {
    Animal.call(this, name); // Call the parent constructor
    this.breed = breed;
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.speak = function() {
    console.log(`${this.name} barks.`);
};

let rex = new Dog('Rex', 'Golden Retriever');
rex.speak(); // Output: Rex barks.


In this example:
Dog inherits from Animal.

Dog.prototype is set to an object created from Animal.prototype.

The speak method is overridden in the Dog constructor.

Introduction to Classes in ES6
ith the introduction of ES6, JavaScript added a new syntax for creating objects and handling inheritance: classes. While classes are mostly syntactic sugar over JavaScript’s existing prototype-based inheritance, they provide a cleaner and more intuitive syntax for working with objects and inheritance.

Defining a Class
A class is defined using the class keyword. Inside a class, you can define a constructor method (for initializing new instances) and other methods.

Example:

class Person {
    constructor(name, age) {
        this.name = name;

        this.age = age;
    }

    greet() {
        console.log(`Hello, my name is ${this.name}.`);
    }
}

let john = new Person('John', 30);
john.greet(); // Output: Hello, my name is John.


Inheritance with Classes
Classes make it easier to set up inheritance using the extends keyword.

Example:

class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        console.log(`${this.name} makes a sound.`);
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // Call the parent constructor

        this.breed = breed;
    }

    speak() {
        console.log(`${this.name} barks.`);
    }
}

let rex = new Dog('Rex', 'Golden Retriever');
rex.speak(); // Output: Rex barks.

In this example:
Dog extends Animal, inheriting its properties and methods.

The super keyword is used to call the parent constructor.

Static Methods and Properties
Static methods and properties belong to the class itself, not to instances of the class.

Example:

class MathHelper {
    static square(x) {
        return x * x;
    }
}

console.log(MathHelper.square(4)); // Output: 16

In this example:
square is a static method, and it is called directly on the MathHelper class.

Understanding the this Keyword
The this keyword in JavaScript refers to the object that is executing the current function. Its value can vary depending on the context in which the function is called.

this in Constructor Functions
In a constructor function, this refers to the instance being created.

Example:

function Car(model) {
    this.model = model;
}

let myCar = new Car('Toyota');
console.log(myCar.model); // Output: Toyota

this in Methods
In methods, this refers to the object that owns the method.

Example:

let car = {
    model: 'Honda',
    start() {
        console.log(`Starting ${this.model}`);
    }
};

car.start(); // Output: Starting Honda

this in Event Handlers
In event handlers, this refers to the element that received the event.

Example:

<button id="myButton">Click me</button>

<script>
    let button = document.getElementById('myButton');
    button.addEventListener('click', function() {
        console.log(this.id); // Output: myButton
    });
</script>

Binding this
In some cases, you might need to explicitly bind this to a specific value, especially when passing methods as callbacks.

Example:

let car = {
    model: 'Ford',

    start() {
        console.log(`Starting ${this.model}`);
    }
};

let startCar = car.start.bind(car);
startCar(); // Output: Starting Ford


Practical Exercise: 
Building a Simple Shopping Cart with Classes

Let’s create a simple shopping cart system using classes.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shopping Cart</title>
</head>

<body>
    <h1>Shopping Cart</h1>
    <ul id="cartItems"></ul>
    <button id="addItem">Add Item</button>

    <script>
        class Item {
            constructor(name, price) {
                this.name = name;
                this.price = price;
            }

            display() {
                return `${this.name}: $${this.price}`;
            }
        }

        class ShoppingCart {
            constructor() {
                this.items = [];
            }

            addItem(item) {
                this.items.push(item);
                this.displayCart();
            }

            displayCart() {
                const cartItems = document.getElementById('cartItems');
                cartItems.innerHTML = '';
                this.items.forEach(item => {
                    let listItem = document.createElement('li');
                    listItem.textContent = item.display();
                    cartItems.appendChild(listItem);
                });
            }
        }

        const cart = new ShoppingCart();

        document.getElementById('addItem').addEventListener('click', () => {
            let newItem = new Item('Apple', 0.99);
            cart.addItem(newItem);
        });
    </script>
</body>
</html>


In this example:
The Item class represents a product in the cart.

The ShoppingCart class manages the list of items and displays them.

The cart updates dynamically when you click the "Add Item" button.

Summary
Object-oriented programming in JavaScript allows you to organize your code more effectively by creating reusable objects and structures. By understanding prototypes, classes, and the this keyword, you can build more complex applications that are modular, scalable, and easier to maintain. As you continue to work with JavaScript, mastering these OOP concepts will be crucial in writing efficient and high-quality code.


2. JavaScript Modules


3. Error Handling


4. Functional Programming in JavaScript


5. Working with APIs


E. JS in Practice
=================

1. DOM Manipulation Projects


2. Working with Events


3. Advanced Asynchronous Programming


4. Performance Optimization


5. Testing and Debugging JavaScript



-->
